Index: app/components/LibraryPage/LibraryPage.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Libs\nimport React                from 'react';\nimport PropTypes            from 'prop-types';\nimport styled               from 'styled-components';\nimport {ThemeContext}       from '../../themes/theme-context';\nimport uuid                 from 'uuid';\nimport { connect }          from 'react-redux';\nimport { compose } from 'redux';\nimport { firestoreConnect, isEmpty} from 'react-redux-firebase';\nimport Masonry              from 'react-masonry-component';\nimport firebase                         from 'firebase';\nimport {isEqual}        from 'lodash';\nimport firestoreUtils from '../../../functions/utils/Firestore';\n\n// Actions\nimport {\n    setAppView,\n    updateRouterState\n} from '../../actions/AppActions';\nimport {\n    setContextMenu\n} from '../../actions/AppActions';\n\n// Components\nimport PageHeader           from '../PageHeader';\nimport DocumentCard         from '../DocumentCard';\nimport GhostButton          from '../GhostButton';\nimport Navbar               from '../Navbar/Navbar';\nimport NavDrawer            from '../NavDrawer/NavDrawer';\nimport EmptyContainer       from '../EmptyContainer';\n\n// Icons\nimport SortIcon             from '../Icons/SortIcon';\nimport GridIcon             from '../Icons/GridIcon';\nimport ListIcon             from '../Icons/ListIcon';\nimport LibraryIcon          from '../Icons/LibraryIcon';\n\n// Constants\nimport Views          from '../../constants/views';\nimport Layouts              from '../../constants/layouts';\nconst DOCUMENTS_COLLECTION = firestoreUtils.collections.documents.NAME;\n\n\n// ============= Redux =============\n\nconst mapStateToProps = state => {\n    return {\n        documents: state.firestore.data[DOCUMENTS_COLLECTION],\n        viewportWidth: state.app.viewportDimensions.width,\n        isMobile: state.app.isMobile\n    };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n      setAppView: view => dispatch(setAppView(view)),\n      updateRouterState: (history, match) => dispatch(updateRouterState(history, match)),\n      setContextMenu: (active, x, y, items, type) => dispatch(setContextMenu(active, x, y, items, type)),\n  };\n};\n\n/**\n * The LibraryPage component is a component used to\n */\nclass LibraryPage extends React.Component {\n    // ============= PropTypes ==============\n\n    static propTypes = {\n        setAppView: PropTypes.func.isRequired,\n        updateRouterState: PropTypes.func.isRequired,\n        viewportWidth: PropTypes.number.isRequired,\n        isMobile: PropTypes.bool.isRequired\n    };\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            layout: Layouts.GRID,\n            layoutChronological: true,\n            tools: {\n                layout: {\n                    active: true,\n                    icon: Layouts.GRID,\n                    handleClick: this.togglePageLayout,\n                    title: \"Toggle Layout\"\n                }\n            },\n            sortType: \"alphabet\",\n            sortBuckets: {\n                all: {\n                    \"All\": []\n                },\n                alphabet: {},\n                type: {\n                    \"Books\": [],\n                    \"Articles\": [],\n                    \"PDF\": []\n                },\n                date: {\n                    \"Today\": [],\n                    \"This Week\": [],\n                    \"This Month\": [],\n                    \"Last Six Months\": [],\n                    \"This Year\": []\n                },\n                popularity: {\n                    \"Must Read\": [],\n                    \"Very Popular\": [],\n                    \"Popular\": [],\n                    \"Mild\": [],\n                    \"Low\": []\n                },\n                insights: {\n                    \"Insights\": []\n                },\n                views: {\n                    \"Views\": []\n                },\n                contributors: {\n                    \"Contributors\": []\n                },\n                votes: {\n                    \"Votes\": []\n                }\n            }\n        }\n    }\n\n    componentWillMount() {\n        //console.log(\"-----LibraryPage\");\n        //window.scrollTop = 0;\n        this.props.updateRouterState(this.props.history, this.props.match);\n        this.props.setAppView(Views.LIBRARY);\n    }\n\n    render() {\n        const tools = {...this.state.tools};\n        tools.layout.icon = this.state.layout == Layouts.GRID ? ListIcon : GridIcon;\n\n        return (\n            <ThemeContext.Consumer>\n                {theme => {\n                    return (\n                        <Container>\n                            <Navbar />\n                            <NavDrawer />\n                            <Toolbar>\n                                <PageHeader>\n                                    Flowheap Library\n                                </PageHeader>\n                                <ToolsContainer>\n                                    <SortContainer>\n                                        <ButtonContainer>\n                                            {\n                                                GhostButton(SortIcon)({\n                                                    width: 30,\n                                                    height: 30,\n                                                    primarycolor: theme.darkGray,\n                                                    opacity: 1,\n                                                    hover: true,\n                                                    padding: true,\n                                                    handleClick: (e) => {this.handleSortClick(e)},\n                                                    ...(!this.props.isMobile ? {\n                                                        \"data-tooltip\": true,\n                                                        \"data-tooltip-at\": \"left\",\n                                                        \"data-info\": \"Sort by\"\n                                                    } : {}),\n                                                    cursor: \"pointer\"\n                                                })\n                                            }\n                                        </ButtonContainer>\n                                        <SortText>\n                                            {`${this.state.sortType[0].toUpperCase()}${this.state.sortType.slice(1)}`}\n                                        </SortText>\n                                    </SortContainer>\n                                    <ButtonContainer>\n                                        {\n                                            GhostButton(this.state.tools.layout.icon)({\n                                                width: 30,\n                                                height: 30,\n                                                primarycolor: theme.darkGray,\n                                                opacity: 1,\n                                                hover: true,\n                                                padding: true,\n                                                handleClick: this.state.tools.layout.handleClick,\n                                                ...(!this.props.isMobile ? {\n                                                    \"data-tooltip\": true,\n                                                    \"data-tooltip-at\": \"left\",\n                                                    \"data-info\": this.state.tools.layout.title\n                                                } : {}),\n                                                cursor: \"pointer\"\n                                            })\n                                        }\n                                    </ButtonContainer>\n                                </ToolsContainer>\n                            </Toolbar>\n                            <DocumentsContainer\n                                isMobile={this.props.isMobile}>\n                                {\n                                    !isEmpty(this.props.documents) ?\n                                        Object.keys(this.state.sortBuckets[this.state.sortType]).sort().map(bucket => {\n                                            if (this.state.sortBuckets[this.state.sortType][bucket].length > 0) {\n                                                return (\n                                                    <React.Fragment key={bucket}>\n                                                        <BucketHeader\n                                                            {...(this.state.sortType == \"alphabet\" ? {\"data-alphabet\": bucket} : {})}>\n                                                            <PageHeader>\n                                                                {bucket}\n                                                            </PageHeader>\n                                                        </BucketHeader>\n                                                        <Masonry\n                                                            elementType={'div'}\n                                                            options={masonryOptions}\n                                                            onImagesLoaded={(images) => {\n                                                                if (Object.keys(images).reduce((allLoaded, image) => {return allLoaded && image.isLoaded}, true)) {\n                                                                    this.setState({})\n                                                                }\n                                                            }}>\n                                                            {this.state.sortBuckets[this.state.sortType][bucket].map(uid => {\n                                                                let doc = this.props.documents[uid];\n                                                                return (\n                                                                    <DocumentCard\n                                                                        key={doc.uid}\n                                                                        data={doc}\n                                                                        width={\"calc(25% - 36px)\"}\n                                                                        hideStats={false}\n                                                                        layout={this.state.layout} />\n                                                                );\n                                                            })}\n                                                        </Masonry>\n                                                    </React.Fragment>\n                                                );\n                                            } else {\n                                                <div/>\n                                            }\n                                        })\n                                    :\n                                        <EmptyContainer\n                                            position={\"absolute\"}\n                                            button={{\n                                                include: false,\n                                                size: this.props.viewportWidth > 900 && !this.props.isMobile ? 250 : 100,\n                                                icon: LibraryIcon\n                                            }}\n                                            text={{\n                                                value: \"Flowheap Library is Empty\",\n                                                size: \"large\"\n                                            }} />\n                                }\n                            </DocumentsContainer>\n                            {this.state.sortType == \"alphabet\" &&\n                                <AlphabetNavigator>\n                                    {Object.keys(this.state.sortBuckets.alphabet).sort().map(glyph => {\n                                        return (\n                                            <Glyph\n                                                key={glyph}\n                                                onClick={() => {this.handleGlyphClick(glyph)}}>\n                                                {glyph}\n                                            </Glyph>\n                                        );\n                                    })}\n                                </AlphabetNavigator>\n                            }\n                        </Container>\n                    );\n                }}\n            </ThemeContext.Consumer>\n        );\n    }\n\n    componentDidMount() {\n        //console.log(\"+++++LibraryPage\");\n        if (this.props.viewportWidth <= 900) {\n            this.setState({\n                layout: Layouts.LIST,\n                tools: {\n                    ...this.state.tools,\n                    layout: {\n                        ...this.state.tools.layout,\n                        active: false\n                    }\n                }\n            });\n        }\n\n        if (!isEmpty(this.props.documents)) {\n            this.createDocumentBuckets(this.props.documents);\n        }\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return true;\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (this.props.viewportWidth > 900 && nextProps.viewportWidth <= 900) {\n            this.setState({\n                layout: Layouts.LIST,\n                tools: {\n                    ...this.state.tools,\n                    layout: {\n                        ...this.state.tools.layout,\n                        active: false\n                    }\n                }\n            });\n        }\n\n        if (this.props.viewportWidth <= 900 && nextProps.viewportWidth > 900) {\n            this.setState({\n                layout: Layouts.GRID,\n                tools: {\n                    ...this.state.tools,\n                    layout: {\n                        ...this.state.tools.layout,\n                        active: true\n                    }\n                }\n            })\n        }\n\n        if (!isEmpty(nextProps.documents) &&\n            !isEqual(this.props.documents, nextProps.documents)) {\n            this.createDocumentBuckets(nextProps.documents);\n        }\n    }\n\n    // ========== Methods ===========\n\n    togglePageLayout = () => {\n        const layout = this.state.layout === Layouts.GRID ? Layouts.LIST : Layouts.GRID;\n        this.setState({\n            layout: layout\n        });\n    }\n\n    sortDocuments = (type) => {\n        let layout;\n        switch (type) {\n            case \"all\":\n            case \"alphabet\":\n            case \"type\":\n            case \"date\":\n            case \"popularity\":\n                layout = Layouts.GRID;\n                break;\n            case \"insights\":\n            case \"views\":\n            case \"contributors\":\n            case \"votes\":\n                layout = Layouts.LIST;\n                break;\n        }\n        this.setState({\n            sortType: type,\n            layout: layout\n        });\n    }\n\n    handleSortClick = (e) => {\n        let options = [\n            {\n                name: \"All\",\n                handleClick: () => {this.sortDocuments(\"all\")}\n            },\n            {\n                name: \"Alphabetical\",\n                handleClick: () => {this.sortDocuments(\"alphabet\")}\n            },\n            {\n                name: \"Type\",\n                handleClick: () => {this.sortDocuments(\"type\")}\n            },\n            {\n                name: \"Date\",\n                handleClick: () => {this.sortDocuments(\"date\")}\n            },\n            {\n                name: \"Popularity\",\n                handleClick: () => {this.sortDocuments(\"popularity\")}\n            },\n            {\n                name: \"Insights\",\n                handleClick: () => {this.sortDocuments(\"insights\")}\n            },\n            {\n                name: \"Views\",\n                handleClick: () => {this.sortDocuments(\"views\")}\n            },\n            {\n                name: \"Contributors\",\n                handleClick: () => {this.sortDocuments(\"contributors\")}\n            },\n            {\n                name: \"Votes\",\n                handleClick: () => {this.sortDocuments(\"votes\")}\n            }\n        ]\n        this.props.setContextMenu(\n            true,\n            e.clientX,\n            e.clientY,\n            options,\n            \"basic\"\n        )\n    }\n\n    handleGlyphClick = (glyph) => {\n        const glyphNode = document.querySelector(`div[data-alphabet='${glyph}']`);\n        glyphNode.scrollIntoView({behavior: \"smooth\"});\n    }\n\n    createDocumentBuckets = (documents) => {\n        // Alphabetical Order\n        let alphabetBuckets = {};\n        Object.keys(documents).forEach(uid => {\n            let title = documents[uid].title\n                .toLowerCase()\n                .replace(\"the\", \"\")\n                .replace(/[.,#!$%^&*;:{}=_`~()\\s\\u0022\\u0027\\u2018\\u2019\\u201C\\u201D]/g,'');\n            let firstLetter = title[0].toUpperCase();\n            if (firstLetter in alphabetBuckets) {\n                alphabetBuckets[firstLetter].push(uid);\n            } else {\n                alphabetBuckets[firstLetter] = [uid];\n            }\n        });\n\n        // Document Type\n        let typeBuckets = {\n            \"Books\": [],\n            \"Articles\": [],\n            \"PDF\": []\n        };\n        Object.keys(documents).forEach(uid => {\n            let type = documents[uid].type;\n            switch (type) {\n                case \"book\":\n                    typeBuckets[\"Books\"].push(uid);\n                    break;\n                case \"article\":\n                    typeBuckets[\"Articles\"].push(uid);\n                    break;\n                case \"pdf\":\n                    typeBuckets[\"PDF\"].push(uid);\n                    break;\n            }\n        });\n\n        // Date\n        let dateBuckets = {\n            \"Today\": [],\n            \"This Week\": [],\n            \"This Month\": [],\n            \"Last Six Months\": [],\n            \"This Year\": []\n        };\n        Object.keys(documents).forEach(uid => {\n            const now = new Date();\n            const DAY_MILLISECONDS = 24 * 60 * 60 * 1000;\n            const WEEK_MILLISECONDS = 7 * DAY_MILLISECONDS;\n            const nowYear = now.getFullYear();\n            const nowMonth = now.getMonth();\n            const nowDay = now.getDate();\n            const dayOfWeek = now.getDay();\n            const lastMidnight = new Date(nowYear, nowMonth, nowDay, 0, 0, 0, 0).getTime();\n            const yesterday = new Date(lastMidnight - DAY_MILLISECONDS).getTime();\n            const lastWeek = new Date(lastMidnight - WEEK_MILLISECONDS - dayOfWeek * DAY_MILLISECONDS).getTime();\n            const lastMonth = new Date(nowMonth == 0 ? nowYear - 1 : nowYear, nowMonth == 0 ? 11 : nowMonth - 1, 0, 0, 0, 0, 0).getTime();\n            const lastSixMonths = new Date(nowMonth - 6 < 0 ? nowYear - 1 : nowYear, nowMonth - 6 < 0 ? 12 - Math.abs((nowMonth - 6) % 11) : nowMonth - 6, 0, 0, 0, 0, 0).getTime();\n            const thisYear = new Date(nowYear, 0, 0, 0, 0, 0, 0).getTime();\n            let docDate = parseInt(documents[uid].uploadDate);\n            if (docDate > yesterday) {\n                dateBuckets[\"Today\"].push(uid);\n            } else if (docDate > lastWeek) {\n                dateBuckets[\"This Week\"].push(uid);\n            } else if (docDate > lastMonth) {\n                dateBuckets[\"This Month\"].push(uid);\n            } else if (docDate > lastSixMonths) {\n                dateBuckets[\"Last Six Months\"].push(uid);\n            } else if (docDate > thisYear) {\n                dateBuckets[\"This Year\"].push(uid);\n            } else {\n                const docYear = new Date(docDate).getFullYear();\n                if (docYear in dateBuckets) {\n                    dateBuckets[docYear].push(uid);\n                } else {\n                    dateBuckets[docYear] = [uid];\n                }\n            }\n        });\n\n        // Popularity\n        let popularityBuckets = {\n            \"1. Must Read\": [],\n            \"2. Very Popular\": [],\n            \"3. Popular\": [],\n            \"4. Mild\": [],\n            \"5. Low\": []\n        };\n\n        let highestPopularity = -1;\n        let lowestPopularity = Infinity;\n\n        Object.keys(documents).forEach(uid => {\n            let insightCount = documents[uid].insightCount;\n            let views = documents[uid].views;\n            let upvotes = Object.keys(documents[uid].votes.up).length;\n            let downvotes = Object.keys(documents[uid].votes.down).length;\n            let popularity = parseInt(insightCount) + parseInt(views) + parseInt(upvotes) + parseInt(downvotes);\n\n            if (popularity > highestPopularity) {\n                highestPopularity = popularity;\n            }\n\n            if (popularity < lowestPopularity) {\n                lowestPopularity = popularity;\n            }\n        });\n\n        let delta = (highestPopularity - lowestPopularity)/5;\n\n        Object.keys(documents).forEach(uid => {\n            let insightCount = documents[uid].insightCount;\n            let views = documents[uid].views;\n            let upvotes = Object.keys(documents[uid].votes.up).length;\n            let downvotes = Object.keys(documents[uid].votes.down).length;\n            let popularity = parseInt(insightCount) + parseInt(views) + parseInt(upvotes) + parseInt(downvotes);\n\n            if (highestPopularity >= popularity &&\n                popularity > (lowestPopularity + 4 * delta)) {\n                popularityBuckets[\"1. Must Read\"].push(uid);\n            } else if ((lowestPopularity + 4 * delta) >= popularity && popularity > (lowestPopularity + 3 * delta)) {\n                popularityBuckets[\"2. Very Popular\"].push(uid);\n            } else if ((lowestPopularity + 3 * delta) >= popularity && popularity > (lowestPopularity + 2 * delta)) {\n                popularityBuckets[\"3. Popular\"].push(uid);\n            } else if ((lowestPopularity + 2 * delta) >= popularity && popularity > (lowestPopularity + delta)) {\n                popularityBuckets[\"4. Mild\"].push(uid);\n            } else {\n                popularityBuckets[\"5. Low\"].push(uid);\n            }\n        });\n\n        this.setState({\n            sortBuckets: {\n                all: {\n                    \"All\": [...Object.keys(documents)]\n                },\n                alphabet: {\n                    ...alphabetBuckets\n                },\n                date: {\n                    ...dateBuckets\n                },\n                type: {\n                    ...typeBuckets\n                },\n                popularity: {\n                    ...popularityBuckets\n                },\n                insights: {\n                    \"Insights\": [...Object.keys(documents).sort((a, b) => {\n                        return documents[b].insightCount - documents[a].insightCount;\n                    })]\n                },\n                views: {\n                    \"Views\": [...Object.keys(documents).sort((a, b) => {\n                        return documents[b].views - documents[a].views;\n                    })]\n                },\n                contributors: {\n                    \"Contributors\": [...Object.keys(documents).sort((a, b) => {\n                        return Object.keys(documents[b].contributors).length - Object.keys(documents[a].contributors).length;\n                    })]\n                },\n                votes: {\n                    \"Votes\": [...Object.keys(documents).sort((a, b) => {\n                        return (Object.keys(documents[b].votes.up).length + Object.keys(documents[b].votes.down).length) - (Object.keys(documents[a].votes.up).length + Object.keys(documents[a].votes.down).length);\n                    })]\n                }\n            }\n        });\n    }\n}\n\n// ============= Styled Components ==============\n\nconst Container = styled.div`\n    width: 100%;\n    min-height: calc(100vh - 60px);\n    margin-top: 60px;\n`;\n\nconst Toolbar = styled.div`\n    position: fixed;\n    top: 60px;\n    left: 0px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin: 0px;\n    width: 100%;\n    height: 60px;\n    border-bottom: ${props => `1px solid ${props.theme.gray}`};\n    background: ${props => props.theme.lightGray};\n    z-index: 1;\n`;\n\nconst BucketHeader = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin: 0px;\n    width: 100%;\n    height: 60px;\n    border-bottom: ${props => `1px solid ${props.theme.gray}`};\n    background: ${props => props.theme.lightGray};\n    z-index: 1;\n`;\n\nconst ButtonContainer = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 50px;\n    height: 50px;\n    margin: 5px;\n    border-radius: 5px;\n    transition: background 0.3s;\n\n    &:hover {\n        background: ${props => props.theme.gray};\n    }\n`;\n\nconst SortContainer = styled.div`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n`;\n\nconst SortText = styled.h3`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    color: ${props => props.theme.darkGray};\n    font-size: 1em;\n    font-weight: 500;\n    margin: 0;\n`;\n\nconst DocumentsContainer = styled.div`\n    position: relative;\n    top: 60px;\n    width: 100%;\n    min-height: calc(100vh - 60px);\n    padding: ${props => props.isMobile ?\n        \"10px 10px 60px 10px\"\n    :\n        \"10px 30px 60px 30px\"\n    };\n    background: ${props => props.theme.lightGray};\n    overflow: scroll;\n`;\n\nconst ToolsContainer = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-around;\n    height: 60px;\n    width: 180px;\n`;\n\nconst AlphabetNavigator = styled.div`\n    display: flex;\n    flex-direction: column;\n    position: fixed;\n    top: calc(50%);\n    right: 0;\n    transform: translateY(-50%);\n    padding: 10px;\n`;\n\nconst Glyph = styled.div`\n    font-size: 0.8em;\n    color: ${props => props.theme.darkGray};\n    font-weight: 600;\n    padding: 2.5px 5px;\n    transition: color 0.3s, transform 0.3s;\n    cursor: pointer;\n\n    &:hover {\n        transform: scale(1.05);\n        color: ${props => props.theme.purple};\n    }\n`;\n\nconst masonryOptions = {\n    transitionDuration: 0\n};\n\nexport default compose(\n    firestoreConnect([DOCUMENTS_COLLECTION]),\n    connect(\n        mapStateToProps,\n        mapDispatchToProps\n    )\n)(LibraryPage);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/components/LibraryPage/LibraryPage.js	(revision f8f74dbd31dcfdc22f81e410294373dcab2fa752)
+++ app/components/LibraryPage/LibraryPage.js	(date 1542326578965)
@@ -27,7 +27,8 @@
 import GhostButton          from '../GhostButton';
 import Navbar               from '../Navbar/Navbar';
 import NavDrawer            from '../NavDrawer/NavDrawer';
-import EmptyContainer       from '../EmptyContainer';
+import EmptyContainer       from '../EmptyContainer'
+import VirtualizedMasonry from '../VirtualizedMasonry/VirtualizedMasonry';
 
 // Icons
 import SortIcon             from '../Icons/SortIcon';
@@ -135,7 +136,7 @@
 
     render() {
         const tools = {...this.state.tools};
-        tools.layout.icon = this.state.layout == Layouts.GRID ? ListIcon : GridIcon;
+        tools.layout.icon = this.state.layout === Layouts.GRID ? ListIcon : GridIcon;
 
         return (
             <ThemeContext.Consumer>
@@ -196,59 +197,9 @@
                             </Toolbar>
                             <DocumentsContainer
                                 isMobile={this.props.isMobile}>
-                                {
-                                    !isEmpty(this.props.documents) ?
-                                        Object.keys(this.state.sortBuckets[this.state.sortType]).sort().map(bucket => {
-                                            if (this.state.sortBuckets[this.state.sortType][bucket].length > 0) {
-                                                return (
-                                                    <React.Fragment key={bucket}>
-                                                        <BucketHeader
-                                                            {...(this.state.sortType == "alphabet" ? {"data-alphabet": bucket} : {})}>
-                                                            <PageHeader>
-                                                                {bucket}
-                                                            </PageHeader>
-                                                        </BucketHeader>
-                                                        <Masonry
-                                                            elementType={'div'}
-                                                            options={masonryOptions}
-                                                            onImagesLoaded={(images) => {
-                                                                if (Object.keys(images).reduce((allLoaded, image) => {return allLoaded && image.isLoaded}, true)) {
-                                                                    this.setState({})
-                                                                }
-                                                            }}>
-                                                            {this.state.sortBuckets[this.state.sortType][bucket].map(uid => {
-                                                                let doc = this.props.documents[uid];
-                                                                return (
-                                                                    <DocumentCard
-                                                                        key={doc.uid}
-                                                                        data={doc}
-                                                                        width={"calc(25% - 36px)"}
-                                                                        hideStats={false}
-                                                                        layout={this.state.layout} />
-                                                                );
-                                                            })}
-                                                        </Masonry>
-                                                    </React.Fragment>
-                                                );
-                                            } else {
-                                                <div/>
-                                            }
-                                        })
-                                    :
-                                        <EmptyContainer
-                                            position={"absolute"}
-                                            button={{
-                                                include: false,
-                                                size: this.props.viewportWidth > 900 && !this.props.isMobile ? 250 : 100,
-                                                icon: LibraryIcon
-                                            }}
-                                            text={{
-                                                value: "Flowheap Library is Empty",
-                                                size: "large"
-                                            }} />
-                                }
+                                <VirtualizedMasonry/>
                             </DocumentsContainer>
-                            {this.state.sortType == "alphabet" &&
+                            {this.state.sortType === "alphabet" &&
                                 <AlphabetNavigator>
                                     {Object.keys(this.state.sortBuckets.alphabet).sort().map(glyph => {
                                         return (
@@ -466,7 +417,7 @@
             const lastMidnight = new Date(nowYear, nowMonth, nowDay, 0, 0, 0, 0).getTime();
             const yesterday = new Date(lastMidnight - DAY_MILLISECONDS).getTime();
             const lastWeek = new Date(lastMidnight - WEEK_MILLISECONDS - dayOfWeek * DAY_MILLISECONDS).getTime();
-            const lastMonth = new Date(nowMonth == 0 ? nowYear - 1 : nowYear, nowMonth == 0 ? 11 : nowMonth - 1, 0, 0, 0, 0, 0).getTime();
+            const lastMonth = new Date(nowMonth === 0 ? nowYear - 1 : nowYear, nowMonth === 0 ? 11 : nowMonth - 1, 0, 0, 0, 0, 0).getTime();
             const lastSixMonths = new Date(nowMonth - 6 < 0 ? nowYear - 1 : nowYear, nowMonth - 6 < 0 ? 12 - Math.abs((nowMonth - 6) % 11) : nowMonth - 6, 0, 0, 0, 0, 0).getTime();
             const thisYear = new Date(nowYear, 0, 0, 0, 0, 0, 0).getTime();
             let docDate = parseInt(documents[uid].uploadDate);
