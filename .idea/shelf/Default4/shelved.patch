Index: app/actions/Insights/InsightCRUDer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import firebase from 'firebase';\nconst storage = firebase.storage();\nconst firestore = firebase.firestore();\n\n// Custom Modules\nimport firestoreUtils from '../../../functions/utils/Firestore';\nimport cloudStorageUtils from '../../../functions/utils/CloudStorage';\nimport InsightVariants from '../../constants/insightVariantTypes';\nimport {SelectionInsight} from \"../../data-structures/Insight\";\n\n// Constants\nconst DOCUMENTS_DIRECTORY = cloudStorageUtils.directories.documents.PERM_UPLOADS;\nconst INSIGHTS_DIRECTORY = cloudStorageUtils.directories.insights.NAME;\nconst INSIGHT_SELECTIONS_DIRECTORY = cloudStorageUtils.directories.insights.selections.NAME;\nconst INSIGHT_SELECTION_PREFIX = cloudStorageUtils.directories.insights.selections.SELECTION_IMAGE_PREFIX;\nconst DOCUMENTS_COLLECTION = firestoreUtils.collections.documents.NAME;\nconst INSIGHTS_COLLECTION = firestoreUtils.collections.insights.NAME;\nconst VIEW_COUNT_INCREMENTER = 1;\n\nexport class InsightCRUDer {\n    constructor (/*Insight*/insight) {\n        this.insight = insight;\n        this.storageDirRef = storage\n            .ref()\n            .child(DOCUMENTS_DIRECTORY)\n            .child(this.insight.doc)\n            .child(INSIGHTS_DIRECTORY)\n            .child(this.insight.uid);\n        this.insightSelectionDirRef = this.storageDirRef.child(INSIGHT_SELECTIONS_DIRECTORY);\n        this.firestoreRef = firestore\n            .collection(INSIGHTS_COLLECTION)\n            .doc(this.insight.uid);\n    }\n\n    uploadBlobsToFirestore() {\n        const uploadName2BlobMap = (name2BlobMap) => {\n            const blobName2DownloadURL = {};\n            let uploadedBlobs = [];\n            for (const name in name2BlobMap) {\n                if (name2BlobMap.hasOwnProperty(name)) {\n                    const blob = name2BlobMap[name];\n                    const blobStorageRef = this.storageDirRef.child(name);\n                    const uploadedBlob = blobStorageRef.put(blob)\n                        .then(() => blobStorageRef.getDownloadURL())\n                        .then(downloadURL => blobName2DownloadURL[name] = downloadURL);\n                    uploadedBlobs.push(uploadedBlob);\n                }\n            }\n            return Promise.all(uploadedBlobs).then(() => {\n                return Object.keys(blobName2DownloadURL)\n                    .reduce((acc, name) => {\n                        const url = blobName2DownloadURL[name];\n                        acc[url] = true;\n                        return acc;\n                    }, {}); \n            });\n        };\n\n        return Promise.all([\n            uploadName2BlobMap(this.insight.media.images),\n            uploadName2BlobMap(this.insight.media.sketches),\n        ]);\n    }\n\n    updateDocumentByRemovingDeletedInsight() {\n        return firestore\n            .collection(DOCUMENTS_COLLECTION)\n            .doc(this.insight.doc)\n            .get()\n            .then(documentSnapshot => {\n                const documentInsightCount = documentSnapshot.get(\"insightCount\");\n                return firestore\n                    .collection(INSIGHTS_COLLECTION)\n                    .where(\"doc\", \"==\", this.insight.doc)\n                    .where(\"user\", \"==\", this.insight.user)\n                    .where(\"isDeleted\", \"==\", false)\n                    .get()\n                    .then(usersInsightsSnapshot => {\n                        const updateObj = {\n                            insightCount: documentInsightCount - VIEW_COUNT_INCREMENTER,\n                        };\n                        if (usersInsightsSnapshot.docs.length === 0) {\n                            updateObj[`contributors.${this.insight.user}`] = firebase.firestore.FieldValue.delete();\n                        }\n                        return documentSnapshot.ref.update(updateObj);\n                    })\n            })\n    }\n    \n    updateDocumentWithNewInsight() {\n        return firestore\n            .collection(DOCUMENTS_COLLECTION)\n            .doc(this.insight.doc)\n            .get()\n            .then(documentSnapshot => {\n                const documentInsightCount = documentSnapshot.get(\"insightCount\");\n                return documentSnapshot.ref.update({\n                    insightCount: documentInsightCount + VIEW_COUNT_INCREMENTER,\n                    [`contributors.${this.insight.user}`]: true,\n                });\n            })\n    }\n\n    updateParentInsightWithNewReplyInsight() {\n        return firestore\n            .collection(INSIGHTS_COLLECTION)\n            .doc(this.insight.parent)\n            .update({[`replies.${this.insight.uid}`]: true});\n    }\n\n    updateParentInsightByRemovingDeletedInsight() {\n        return firestore\n            .collection(INSIGHTS_COLLECTION)\n            .doc(this.insight.parent)\n            .update({[`replies.${this.insight.uid}`]: firebase.firestore.FieldValue.delete()});\n    }\n\n    uploadSelectionBlobForSelectionInsight(/*Blob*/blob) {\n        const blobStorageRef = this.insightSelectionDirRef\n            .child(`${INSIGHT_SELECTION_PREFIX}1`);\n        return blobStorageRef.put(blob)\n            .then(() => blobStorageRef.getDownloadURL())\n    }\n\n    createNewInsight(/*Blob*/selectionBlob = null) {\n        return this.updateDocumentWithNewInsight()\n            .then(() => {\n                let promise = Promise.resolve();\n                if (this.insight.variant === InsightVariants.REPLY) {\n                    promise = this.updateParentInsightWithNewReplyInsight()\n                }\n                return promise;\n            })\n            .then(() => {\n                return this.uploadBlobsToFirestore()\n            })\n            .then(values => {\n                const imageURLsObj = values[0], sketchURLsObj = values[1];\n                const defaultInsight = this.insight.getDocumentFields();\n                const finalInsightObj = {\n                    ...defaultInsight,\n                    media: {\n                        ...defaultInsight.media,\n                        images: imageURLsObj,\n                        sketches: sketchURLsObj,\n                    },\n                };\n\n                // upload the selection blob if insight is a selection insight\n                let insightTypeDependentAction = Promise.resolve();\n                if (this.insight instanceof SelectionInsight) {\n                    if (this.insight.variant === InsightVariants.BASIC) {\n                        insightTypeDependentAction = this.uploadSelectionBlobForSelectionInsight(selectionBlob)\n                            .then(selectionURL => {\n                                finalInsightObj.quote.box.imageURL = selectionURL\n                            })\n                    }\n                }\n\n                return insightTypeDependentAction\n                    .then(() => this.firestoreRef.set(finalInsightObj).then(() => {\n                        return finalInsightObj;\n                    }));\n            })\n    }\n\n    static UpdateExistingInsight(insightUID, updateObj) {\n        const firestoreUpdateObj = {};\n        for (const keyPath in updateObj) {\n            if (updateObj.hasOwnProperty(keyPath)) {\n                if (updateObj[keyPath] === DELETE_INSIGHT_FIELD) {\n                    firestoreUpdateObj[keyPath] = firebase.firestore.FieldValue.delete();\n                } else {\n                    firestoreUpdateObj[keyPath] = updateObj[keyPath];\n                }\n            }\n        }\n\n        const docRef = firestore\n            .collection(INSIGHTS_COLLECTION)\n            .doc(insightUID);\n\n        // NOTE: because have firestore listeners for 3 separate classes\n        // of insights: public, limited that you're a part of and\n        // your private insights, firestoreConnect will delete the\n        // local copy of the insight when the insights privacy scop\n        // changes so a hack fix is to edit the document with a fake\n        // edit and then delete is so that the new privacy scope\n        // listener will download the updated version of the insight\n        // gagain\n        return docRef\n            .update(firestoreUpdateObj)\n            .then(() => docRef.update({dummyField: Math.random()}))\n            .then(() => docRef.update({dummyField: firebase.firestore.FieldValue.delete()}));\n    }\n\n\n\n    deleteInsight() {\n        return this.firestoreRef\n            .update({isDeleted: true})\n            .then(() => {\n                if (this.insight.variant === InsightVariants.REPLY) {\n                    return this.updateParentInsightByRemovingDeletedInsight()\n                } else {\n                    return Promise.resolve();\n                }\n            })\n            .then(() => this.updateDocumentByRemovingDeletedInsight())\n    }\n}\n\nexport const DELETE_INSIGHT_FIELD = \"delete field\";
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/actions/Insights/InsightCRUDer.js	(date 1543432850000)
+++ app/actions/Insights/InsightCRUDer.js	(date 1543443581573)
@@ -187,7 +187,7 @@
         // changes so a hack fix is to edit the document with a fake
         // edit and then delete is so that the new privacy scope
         // listener will download the updated version of the insight
-        // gagain
+        // again
         return docRef
             .update(firestoreUpdateObj)
             .then(() => docRef.update({dummyField: Math.random()}))
Index: app/components/ReadingPage/DocumentAssets/PDFPage.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Libs\nimport React                            from 'react';\nimport styled                           from 'styled-components';\nimport { Page }              from 'react-pdf';\nimport { connect }                      from 'react-redux';\nimport {\n    isEqual,\n    pickBy,\n    mapValues,\n    isEmpty,\n    throttle\n}                                       from 'lodash';\n\n// Actions\nimport {\n    setBucketIndex2Insights,\n    setSelectionOrHighlightInsightData,\n    setNewInsightDialog\n} from '../../../actions/ReadingPageActions';\nimport {getInsightsCollectionFromStore} from '../../../actions/Utils';\n\n// Components\nimport Loader                           from '../../Loader';\nimport MarginaliaCard                   from '../../MarginaliaCard';\nimport MarginaliaContractor             from '../../MarginaliaContractor';\n\n// Custom Modules\nimport PropTypes from \"prop-types\";\n\n// Constants\n\nimport {\n    DOCUMENT_ASSETS_DEFAULT_PAGE_HEIGHT,\n    DOCUMENT_ASSETS_DEFAULT_PAGE_WIDTH,\n    DEFAULT_MARGINALIA_BUCKET_HEIGHT\n} from '../../../constants/generalAppConstants';\n\nconst mapStateToProps = (state, props) => {\n    let pageInsights = {};\n    let readingToolbar = state.app.readingToolbar;\n    let insightsIsActive = state.app.readingPageInsights.active;\n    const viewportHeight = state.app.viewportDimensions.height;\n\n    // avoid unnecessary computation only computing real props\n    // when the page is visible\n    if (props.isVisible) {\n        const insights = getInsightsCollectionFromStore(state);\n\n        pageInsights = (\n            insights\n            && props.pageInsightUIDs\n            && mapValues(props.pageInsightUIDs, (_, insightUID) => insights[insightUID])\n        ) || {};\n    }\n\n    return {\n        pageInsights,\n        readingToolbar,\n        insightsIsActive,\n        viewportHeight\n    }\n};\n\nconst mapDispatchToProps = dispatch => {\n    return {\n        setBucketIndex2Insights: (newBucketIndex2Insights) => dispatch(setBucketIndex2Insights(newBucketIndex2Insights)),\n        setSelectionOrHighlightInsightData: data => dispatch(setSelectionOrHighlightInsightData(data)),\n        setNewInsightDialog: () => dispatch(setNewInsightDialog(/*todo*/)),\n    }\n};\n\n/**\n * The ReadingPage component is a component used to\n */\nclass PDFPage extends React.Component {\n    // ============= PropTypes ==============\n    static propTypes = {\n        pageIndex: PropTypes.number.isRequired,\n        measure: PropTypes.func.isRequired,\n        isVisible: PropTypes.bool.isRequired,\n        pageWidth: PropTypes.number.isRequired,\n        insightsIsActive: PropTypes.bool.isRequired,\n        viewportWidth: PropTypes.number.isRequired,\n        docUID: PropTypes.string.isRequired,\n        readingToolbar: PropTypes.object.isRequired\n    };\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            pdfAnnotation: {\n                isAnnotating: false,\n                selection: {},\n                box: {\n                    blob: undefined,\n\n                },\n            },\n            dimensions: {\n                height: undefined,\n                width: undefined,\n            },\n            numBuckets: undefined,\n            marginaliaBuckets: {},\n            tempBoundingBox: {\n                active: false,\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            },\n            prevMarginaliaBucketLengths: {},\n        };\n        this.handleScroll = throttle(this.handleScroll.bind(this), 600, {leading: false, trailing: true});\n    }\n\n    componentWillMount() {\n        //console.log(\"-----ReadingPage\");\n    }\n\n    render() {\n        const index = this.props.pageIndex;\n\n        const annotationState = this.state.pdfAnnotation;\n        const annotationSelection = annotationState.selection;\n        let pageSelector = {width: 0, height: 0, left: 0, top: 0};\n        if (annotationState.isAnnotating) {\n            pageSelector.width = Math.abs(annotationSelection.start.x - annotationSelection.end.x);\n            pageSelector.height = Math.abs(annotationSelection.start.y - annotationSelection.end.y);\n            pageSelector.left = Math.min(annotationSelection.start.x, annotationSelection.end.x);\n            pageSelector.top = Math.min(annotationSelection.start.y, annotationSelection.end.y);\n        }\n        const annotationSelectionStyle = {\n            top: pageSelector.top + \"px\",\n            left: pageSelector.left + \"px\",\n            width: pageSelector.width + \"px\",\n            height: pageSelector.height + \"px\",\n        };\n\n        const tempBoundingBoxStyle = {\n            top: `${this.state.tempBoundingBox.y}px`,\n            left: `${this.state.tempBoundingBox.x}px`,\n            width: `${this.state.tempBoundingBox.width}px`,\n            height: `${this.state.tempBoundingBox.height}px`\n        };\n        const {marginaliaBuckets, dimensions: pageDimensions} = this.state;\n\n        return (\n            <Page\n                className={`pdf-page page-wrapper-${this.props.pageIndex}`}\n                loading={this.renderPagePlaceholder()}\n                width={this.props.pageWidth}\n                renderAnnotations={false}\n                renderTextLayer={false}\n                pageIndex={index}\n                onLoadSuccess={() => this.onPageLoadSuccess()}>\n                <BoundingBoxSelection\n                    active={true}\n                    id={`pdf-page-annotation-selection-${index}`}\n                    style={annotationSelectionStyle}\n                />\n                <BoundingBoxSelection\n                    active={this.state.tempBoundingBox.active}\n                    style={tempBoundingBoxStyle} />\n                {this.props.insightsIsActive &&\n                <MarginaliaContainer\n                    width={(this.props.viewportWidth - this.props.pageWidth)/2}>\n                    {Object.keys(marginaliaBuckets)\n                        .map(bucketOffset => {\n                            const bucketIndex = parseInt(bucketOffset) + parseInt(index) * parseInt(this.state.numBucketsPerPage);\n                            if (Object.keys(marginaliaBuckets[bucketOffset]).length > 1) {\n                                return (\n                                    <MarginaliaBucket\n                                        key={`marginalia page-${index} bucket-${bucketOffset}`}\n                                        top={bucketOffset * DEFAULT_MARGINALIA_BUCKET_HEIGHT}>\n                                        <MarginaliaContractor\n                                            data={marginaliaBuckets[bucketOffset]}\n                                            orientation={\"left\"}\n                                            allParagraphMarginalia={true}\n                                            pageDimensions={pageDimensions}\n                                            userUIDs={Object.keys(marginaliaBuckets[bucketOffset])\n                                                .map(insightUID => {\n                                                    return marginaliaBuckets[bucketOffset][insightUID].user;\n                                                })}\n                                            numInsights={Object.keys(marginaliaBuckets[bucketOffset]).length}\n                                            bucketIndex={bucketIndex}\n                                        />\n                                    </MarginaliaBucket>\n                                );\n                            } else {\n                                return (\n                                    <MarginaliaBucket\n                                        key={`marginalia page-${index} bucket-${bucketOffset}`}\n                                        top={bucketOffset * DEFAULT_MARGINALIA_BUCKET_HEIGHT}>\n                                        {Object.keys(marginaliaBuckets[bucketOffset]).map(uid => {\n                                            const note = marginaliaBuckets[bucketOffset][uid];\n                                            return (\n                                                <MarginaliaCard\n                                                    key={uid}\n                                                    data={note}\n                                                    pageIndex={index}\n                                                    pageDimensions={pageDimensions}\n                                                    paragraphIndex={null}\n                                                    docUID={this.props.docUID}\n                                                    orientation={\"left\"}\n                                                    bucketIndex={bucketIndex}\n                                                />\n                                            );\n                                        })}\n                                    </MarginaliaBucket>\n                                );\n                            }\n                        })}\n                </MarginaliaContainer>\n                }\n            </Page>\n        );\n    };\n\n    componentDidMount() {\n        //console.log(\"+++++ReadingPage\");\n        window.addEventListener(\"scroll\", this.handleScroll);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener(\"scroll\", this.handleScroll);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        // re-compute the displaying of buckets that marginalia belong\n        // to if the number of insights for this page changes\n\n        this.computePageBucket(nextProps.pageInsights, nextProps.isVisible);\n\n        if (this.props.readingToolbar.active && !nextProps.readingToolbar.active) {\n            this.setTempBoundingBox({\n                active: false,\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            });\n        }\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        //console.log(\"+++++ReadingPage\");\n\n        // update store's BucketIndex2InsightUIDs when insights are created or deleted.\n        // Skip entirely when page is not visible to avoid unnecessary computation\n        const prevMarginaliaBucketLengths = mapValues(prevState.marginaliaBuckets, bucket => Object.keys(bucket).length);\n        const currMarginaliaBucketLengths = mapValues(this.state.marginaliaBuckets, bucket => Object.keys(bucket).length);\n        const marginaliaBuckets = this.state.marginaliaBuckets;\n\n\n        if (this.props.isVisible && !isEqual(prevMarginaliaBucketLengths, currMarginaliaBucketLengths)) {\n            const newBucketIndex2Insights = {};\n\n            for (const bucketOffset in marginaliaBuckets) {\n                if (marginaliaBuckets.hasOwnProperty(bucketOffset)) {\n                    const prevBucketCount = prevMarginaliaBucketLengths[bucketOffset];\n                    const currBucketCount = currMarginaliaBucketLengths[bucketOffset];\n\n                    if ((prevBucketCount === undefined && currBucketCount > 0)\n                        || (prevBucketCount >= 0 && currBucketCount >= 0 && prevBucketCount !== currBucketCount)) {\n                        const numBuckets = Object.keys(marginaliaBuckets).length;\n                        const bucketIndex = numBuckets * parseInt(this.props.pageIndex) + parseInt(bucketOffset);\n                        newBucketIndex2Insights[bucketIndex] = mapValues(marginaliaBuckets[bucketOffset], () => true);\n                    }\n                }\n            }\n\n            if (!isEmpty(newBucketIndex2Insights)) {\n                this.props.setBucketIndex2Insights(newBucketIndex2Insights);\n            }\n        }\n    }\n\n    // ========== Methods ===========\n    handleScroll = event => {\n        const page = document.querySelector(`div.page-wrapper-${this.props.pageIndex}`);\n        if (page) {\n            const pageVerticalOffset = page.getBoundingClientRect().y;\n            const pageIsInFocus = 0 < pageVerticalOffset && pageVerticalOffset < Math.floor(this.props.viewportHeight);\n            if (pageIsInFocus) {\n                this.props.setCurrentPage(this.props.pageIndex);\n            }\n        }\n    };\n\n    renderPagePlaceholder = () => {\n        return (\n            <PlaceholderPage>\n                <Loader/>\n            </PlaceholderPage>\n        );\n    };\n\n    onPageLoadSuccess = () => {\n        this.props.measure();\n        const index = this.props.pageIndex;\n\n        const canvas = document.querySelector(`div.pdf-page[data-page-number='${index+1}'] canvas`);\n        canvas.onmousedown = (event) => this.beginPDFAnnotationSelection(event, index);\n        canvas.onmousemove = this.updateSecondSelectionCoordinate;\n        canvas.onmouseup = (event) => this.stopPDFAnnotationSelection(event);\n\n        this.state.dimensions = {\n            width: canvas.clientWidth,\n            height: canvas.clientHeight,\n        };\n\n        this.computePageBucket(this.props.pageInsights, this.props.isVisible);\n    };\n\n    beginPDFAnnotationSelection = (event, pageIndex) => {\n        this.setState({\n            pdfAnnotation: {\n                isAnnotating: true,\n                selection: {\n                    start: {\n                        x: event.offsetX,\n                        y: event.offsetY,\n                    },\n                    end: {\n                        x: event.offsetX,\n                        y: event.offsetY,\n                    },\n                },\n                pageIndex,\n            }\n        });\n    };\n\n    updateSecondSelectionCoordinate = (event) => {\n        if (this.state.pdfAnnotation.isAnnotating) {\n            this.setState({\n                pdfAnnotation: {\n                    ...this.state.pdfAnnotation,\n                    selection: {\n                        ...this.state.pdfAnnotation.selection,\n                        end: {\n                            x: event.offsetX,\n                            y: event.offsetY,\n                        }\n                    }\n                }\n            }/*, console.log('updateSecondSelectionCoordinate', this.state.pdfAnnotation.selection)*/);\n        }\n    };\n\n    stopPDFAnnotationSelection = (event) => {\n        const canvas = event.target || event.srcElement;\n        this.state.pdfAnnotation = {\n            ...this.state.pdfAnnotation,\n            isAnnotating: false,\n            selection: {\n                ...this.state.pdfAnnotation.selection,\n                end: {\n                    x: event.offsetX,\n                    y: event.offsetY,\n                }\n            }\n        };\n        const {x: startX, y: startY} = this.state.pdfAnnotation.selection.start;\n        const {x: endX, y: endY} = this.state.pdfAnnotation.selection.end;\n\n        // compute scaling factors from visible canvas to actual canvas\n        // since the canvas's context is of different dimensions than\n        // the visible canvas\n        const actualHeight = canvas.height;\n        const visibleHeight = parseInt(canvas.style.height);\n        const verticalScalingFactor = actualHeight / visibleHeight;\n        const actualWidth = canvas.width;\n        const visibleWidth = parseInt(canvas.style.width);\n        const horizontalScalingFactor = actualWidth / visibleWidth;\n\n        // compute the bounding box represented by the user's selection\n        const upperLeftX = Math.min(startX, endX) * horizontalScalingFactor;\n        const upperLeftY = Math.min(startY, endY) * verticalScalingFactor;\n        const selectionWidth = Math.abs(startX - endX) * horizontalScalingFactor;\n        const selectionHeight = Math.abs(startY - endY) * verticalScalingFactor;\n\n        // re-create the selection on a dummy canvas scaled 1:1 with\n        // the selection itself\n        const dummyCanvas = document.createElement('canvas');\n        dummyCanvas.width = selectionWidth;\n        dummyCanvas.height = selectionHeight;\n        const dummyCtx = dummyCanvas.getContext('2d');\n        dummyCtx.drawImage(\n            canvas,\n            upperLeftX,\n            upperLeftY,\n            selectionWidth,\n            selectionHeight,\n            0, 0,\n            selectionWidth,\n            selectionHeight\n        );\n\n        // saved the dummy canvas content to extract the image\n        // of the user's selection (annotation)\n        const selectionAsBlob = new Promise(resolve => dummyCanvas.toBlob(resolve, 'image/png', 0));\n        this.state.pdfAnnotation = {\n            isAnnotating: false,\n            box: {\n                blob: selectionAsBlob,\n                canvas: {\n                    actual: {\n                        width: actualWidth,\n                        height: actualHeight,\n                    },\n                    visible: {\n                        width: visibleWidth,\n                        height: visibleHeight,\n                    }\n                },\n                selection: {\n                    upperLeft: {\n                        x: upperLeftX,\n                        y: upperLeftY,\n                    },\n                    dimensions: {\n                        width: selectionWidth,\n                        height: selectionHeight,\n                    }\n                },\n                pageIndex: this.state.pdfAnnotation.pageIndex,\n            }\n        };\n        const selection = this.state.pdfAnnotation.box.selection;\n        const canvasDimensions = this.state.pdfAnnotation.box.canvas.actual;\n        const pageDimensions = this.state.dimensions;\n        const boundingBoxDimensions = {\n            active: true,\n            x: pageDimensions.width * (selection.upperLeft.x/canvasDimensions.width),\n            y: pageDimensions.height * (selection.upperLeft.y/canvasDimensions.height),\n            width: pageDimensions.width * (selection.dimensions.width/canvasDimensions.width),\n            height: pageDimensions.height * (selection.dimensions.height/canvasDimensions.height)\n        };\n        this.setTempBoundingBox(boundingBoxDimensions);\n\n        selectionAsBlob\n            .then(blob => {\n                const data = {\n                    ...this.state.pdfAnnotation.box,\n                    blob,\n                };\n                return this.props.setSelectionOrHighlightInsightData(data);\n            });\n    };\n\n    setTempBoundingBox = (data) => {\n        this.setState({\n            tempBoundingBox: {\n                ...data\n            }\n        });\n    };\n\n    computePageBucket = (insights, isVisible) => {\n        if (!isVisible) { return }\n\n        const height = this.state.dimensions.height || DOCUMENT_ASSETS_DEFAULT_PAGE_HEIGHT;\n        const marginaliaBuckets = {};\n\n        // recompute the number of buckets on a page\n        let numBuckets = 0;\n        while (numBuckets * DEFAULT_MARGINALIA_BUCKET_HEIGHT < height) {\n            marginaliaBuckets[numBuckets] = {};\n            numBuckets += 1;\n        }\n\n        // determine which buckets each insight belongs\n        // to based on its vertical offset\n        for (let uid in insights) {\n            if (insights.hasOwnProperty(uid)) {\n                const adjustedY = height * (insights[uid].quote.box.selection.upperLeft.y / insights[uid].quote.box.canvas.actual.height);\n                const bucketIndex = Math.floor(adjustedY/DEFAULT_MARGINALIA_BUCKET_HEIGHT);\n                marginaliaBuckets[bucketIndex][uid] = insights[uid];\n            }\n        }\n\n        this.setState({\n            marginaliaBuckets,\n            numBucketsPerPage: numBuckets,\n        });\n    };\n\n}\n\n// ============= Styled Components ==============\n\nconst PlaceholderPage = styled.div`\n    width: ${() => DOCUMENT_ASSETS_DEFAULT_PAGE_WIDTH}px;\n    height: ${() => DOCUMENT_ASSETS_DEFAULT_PAGE_HEIGHT}px;\n    background: ${props => props.theme.white};\n`;\n\nconst BoundingBoxSelection = styled.div`\n    visibility: ${props => props.active ? \"visible\" : \"hidden\"};\n    opacity: ${props => props.active ? 1 : 0};\n    position: absolute;\n    border-radius: 5px;\n    background: rgba(101, 38, 109, 0.38);\n    pointer-events: none;\n    transition: visibility 0.3s, opacity 0.3s;\n`;\n\n\nconst MarginaliaContainer = styled.div`\n    position: absolute;\n    top: 0;\n    right: -5px;\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: flex-start;\n    width: ${props => `${props.width}px`};\n    height: 100%;\n    transform: translateX(100%);\n\n    @media (max-width: 100ch) {\n        right: 0px;\n        transform: translateX(0%);\n        width: auto;\n    }\n`;\n\nconst MarginaliaBucket = styled.div`\n    display: flex;\n    align-items: center;\n    width: 100%;\n    height: ${() => `${DEFAULT_MARGINALIA_BUCKET_HEIGHT}px`};\n`;\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(PDFPage);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/components/ReadingPage/DocumentAssets/PDFPage.js	(date 1543432850000)
+++ app/components/ReadingPage/DocumentAssets/PDFPage.js	(date 1543430286340)
@@ -193,11 +193,10 @@
                                         key={`marginalia page-${index} bucket-${bucketOffset}`}
                                         top={bucketOffset * DEFAULT_MARGINALIA_BUCKET_HEIGHT}>
                                         {Object.keys(marginaliaBuckets[bucketOffset]).map(uid => {
-                                            const note = marginaliaBuckets[bucketOffset][uid];
                                             return (
                                                 <MarginaliaCard
                                                     key={uid}
-                                                    data={note}
+                                                    insightUID={uid}
                                                     pageIndex={index}
                                                     pageDimensions={pageDimensions}
                                                     paragraphIndex={null}
Index: app/reducers/insightReducer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {\n    USER_LOGGED_OUT,\n    SET_SKETCH,\n    SET_SELECTED_INSIGHT,\n    SET_SELECTION_HIGHLIGHT_INSIGHT_DATA,\n    DELETE_INSIGHT,\n    NAVIGATE_TO_QUOTE_CONTEXT,\n    STAGE_MARGINALIA,\n    UNSTAGE_MARGINALIA,\n    UNSTAGE_ALL_HIGHLIGHT_MARGINALIA,\n    SET_BUCKET_INDEX_2_INSIGHTS, CLEAR_BUCKET_INDEX_2_INSIGHTS,\n} from \"../constants/actionTypes\";\nimport {sortBy, sortedUniqBy, omit, omitBy, isEmpty} from \"lodash\";\n\nconst initialState = {\n    sketchBlob: {},\n    newInsight: {},\n    currentBucketIndex: undefined,\n    selectedInsightUID: undefined,\n    seeInContext: {\n        highlights: {}, // {pageIndex, paragraphIndex, insightUID}\n        selections: {}, // {pageIndex, insightUID}\n    },\n    stagedMarginalia: {\n        highlights: {}, // {insightUID: {startBit, endBit, isQuestion}\n        selections: {}, // {insightUID: true}\n    },\n    bucketIndex2InsightUIDs: {},\n};\n\nconst insightReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case SET_SKETCH:\n            return {\n                ...state,\n                sketchBlob: action.payload\n            };\n        case SET_SELECTION_HIGHLIGHT_INSIGHT_DATA:\n            return {\n                ...state,\n                newInsight: action.payload,\n            };\n        case DELETE_INSIGHT: {\n            // remove the deleted insight from its buckets in\n            // bucketIndex2InsightUIDs for Highlight Insights\n            const {insightUID, paragraphs} = action.payload;\n            let newBucketIndex2InsightUIDs = {...state.bucketIndex2InsightUIDs};\n            if (paragraphs) {\n                const {start, end} = paragraphs;\n                for (let i = start; i <= end; i++) {\n                    newBucketIndex2InsightUIDs[i] = omit(newBucketIndex2InsightUIDs[i], insightUID)\n                }\n            }\n\n            return {\n                ...state,\n                selectedInsightUID: undefined,\n                bucketIndex2InsightUIDs: newBucketIndex2InsightUIDs,\n            };\n        }\n        case SET_SELECTED_INSIGHT:\n            const {insightUID, paragraphIndex} = action.payload;\n            return {\n                ...state,\n                selectedInsightUID: insightUID,\n                currentBucketIndex: paragraphIndex\n            };\n        case STAGE_MARGINALIA: {\n            return {\n                ...state,\n                stagedMarginalia: {\n                    ...state.stagedMarginalia,\n                    highlights: {\n                        ...state.stagedMarginalia.highlights,\n                        ...action.payload.highlights,\n                    },\n                    selections: {\n                        ...state.stagedMarginalia.selections,\n                        ...action.payload.selections,\n                    }\n                }\n            }\n        }\n        case UNSTAGE_MARGINALIA: {\n            return {\n                ...state,\n                stagedMarginalia: {\n                    ...state.stagedMarginalia,\n                    highlights: omit(state.stagedMarginalia.highlights, action.payload.highlights),\n                    selections: omit(state.stagedMarginalia.selections, action.payload.selections)\n                }\n            }\n        }\n        case UNSTAGE_ALL_HIGHLIGHT_MARGINALIA: {\n            return {\n                ...state,\n                seeInContext: {\n                    ...state.seeInContext,\n                    highlights: {},\n                    selections: {},\n                },\n                stagedMarginalia: {\n                    ...state.stagedMarginalia,\n                    highlights: {},\n                    selections: {},\n                },\n            }\n        }\n        case NAVIGATE_TO_QUOTE_CONTEXT: {\n            return {\n                ...state,\n                ...action.payload,\n            }\n        }\n        case SET_BUCKET_INDEX_2_INSIGHTS: {\n            const updates = action.payload;\n            const combined = {\n                ...state.bucketIndex2InsightUIDs,\n                ...updates,\n            };\n            const remaining = omitBy(\n                combined,\n                (_, paragraphIndex) =>  updates[paragraphIndex] !== undefined ? isEmpty(updates[paragraphIndex]) : false\n            );\n            return {\n                ...state,\n                bucketIndex2InsightUIDs: remaining,\n            }\n        }\n        case CLEAR_BUCKET_INDEX_2_INSIGHTS:\n        case USER_LOGGED_OUT: {\n            return initialState;\n        }\n        default:\n            return state;\n    }\n};\n\nexport default insightReducer;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/reducers/insightReducer.js	(date 1543432850000)
+++ app/reducers/insightReducer.js	(date 1543449767970)
@@ -66,6 +66,7 @@
                 currentBucketIndex: paragraphIndex
             };
         case STAGE_MARGINALIA: {
+            console.log('STAGE_MARGINALIA', action.payload);
             return {
                 ...state,
                 stagedMarginalia: {
Index: app/components/MarginaliaCard.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Libs\nimport React                from 'react';\nimport PropTypes            from 'prop-types';\nimport styled               from 'styled-components';\nimport {\n    ThemeContext,\n    theme as themeColors\n}       from '../themes/theme-context';\nimport firestoreUtils from '../../functions/utils/Firestore';\nimport { connect }          from 'react-redux';\nimport { compose }                      from 'redux';\nimport {isEqual, forOwn}            from 'lodash';\nimport {\n    firestoreConnect,\n    isEmpty\n} from 'react-redux-firebase';\n\nimport {\n    documentInsightRoute,\n    insightsQueryFromCondition,\n    insightShouldBeVisibleToViewingUser\n} from '../actions/Utils';\n\n// Actions\nimport {\n    setContextMenu,\n    setSnackbar,\n    addToClipboard\n} from '../actions/AppActions';\n\nimport {\n    updateInsight,\n    setInsightViewerDialog,\n    setSelectedInsight,\n    setStagedMarginalia,\n} from '../actions/ReadingPageActions';\n\n// Components\nimport VisibilityIcon       from './HOC/VisibilityIcon';\nimport TimeBeforeFormat     from './HOC/TimeBeforeFormat';\nimport GhostButton          from './GhostButton';\nimport Image                from './Image';\nimport Loader               from './Loader';\nimport ToggleInput          from './ToggleInput';\nimport Button               from './Button';\n\n// Icons\nimport MoreIcon             from './Icons/MoreIcon';\nimport UserProfileIcon      from './Icons/UserProfileIcon';\nimport TextIcon             from './Icons/TextIcon';\nimport LinkIcon             from './Icons/LinkIcon';\nimport ImageIcon            from './Icons/ImageIcon';\nimport SketchIcon           from './Icons/SketchIcon';\nimport QuestionIcon         from './Icons/QuestionIcon';\nimport QuoteIcon            from './Icons/QuoteIcon';\nimport SpeechBubbleIcon     from './Icons/SpeechBubbleIcon';\n\n// Actions\nimport {\n    extractURLMetaTags,\n    getInsightsCollectionFromStore\n} from '../actions/Utils';\n\n// Constants\nconst USERS_COLLECTION = firestoreUtils.collections.users.NAME;\nconst INSIGHTS_COLLECTION = firestoreUtils.collections.insights.NAME;\nconst DOCUMENTS_COLLECTION = firestoreUtils.collections.documents.NAME;\nimport InsightTypes         from '../constants/insightTypes';\nimport ColorTypes           from '../constants/colorTypes';\nimport MarginaliaViewTypes  from '../constants/marginaliaViewTypes';\nimport InsightVariantTypes  from \"../constants/insightVariantTypes\";\nimport QuestionStates       from '../constants/questionStates';\n\n// ============= Redux =============\n\nconst mapStateToProps = (state, props) => {\n    const firestoreData = state.firestore.data;\n    const currentUserUID = state.profile.currentUser.metadata.uid;\n    const docUID = props.data.doc;\n    const insightsCollection = getInsightsCollectionFromStore(state);\n    const documentsCollection = !!firestoreData && firestoreData[DOCUMENTS_COLLECTION];\n    const usersCollection = !!firestoreData && firestoreData[USERS_COLLECTION];\n    let replyInsights = [];\n    let activeDoc = {};\n\n    if (insightsCollection && currentUserUID) {\n        Object.keys(props.data.replies).forEach(uid => {\n            const insight = insightsCollection[uid];\n            if (insight && insightShouldBeVisibleToViewingUser(insight, currentUserUID, InsightVariantTypes.REPLY)) {\n                replyInsights.push(insightsCollection[uid]);\n            }\n        });\n    }\n\n    if (documentsCollection &&\n        documentsCollection[docUID]) {\n        activeDoc = {...documentsCollection[docUID]};\n    }\n\n    let user = {};\n    if (props.data.user !== \"Author\"\n        && usersCollection\n        && usersCollection[props.data.user]) {\n        user = {...usersCollection[props.data.user]};\n    }\n\n    return {\n        user,\n        replyInsights,\n        history: state.app.router.history,\n        isMobile: state.app.isMobile,\n        viewportDimensions: state.app.viewportDimensions,\n        currentUser: state.profile.currentUser.metadata,\n        viewer: state.insights.viewer,\n        hasQuestion: props.data.question === QuestionStates.UNRESOLVED_QUESTION,\n        stagedMarginalia: state.insights.stagedMarginalia.selections,\n        activeDoc,\n        settings: state.profile.settings\n    };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n      setContextMenu: (active, x, y, items, type) => dispatch(setContextMenu(active, x, y, items, type)),\n      setSnackbar: data => dispatch(setSnackbar(data)),\n      addToClipboard: (title, link) => dispatch(addToClipboard(title, link)),\n      updateInsight: (uid, updateObj) => dispatch(updateInsight(uid, updateObj)),\n      setInsightViewerDialog: data => dispatch(setInsightViewerDialog(data)),\n      setSelectedInsight: (insightUID, paragraphIndex) => dispatch(setSelectedInsight(insightUID, paragraphIndex)),\n      setStagedMarginalia: (marginalia, active) => dispatch(setStagedMarginalia(marginalia, active)),\n  };\n};\n\n/**\n * The MarginaliaCard component is a component used to\n */\nclass MarginaliaCard extends React.Component {\n    // ============= PropTypes ==============\n\n    static propTypes = {\n        setContextMenu: PropTypes.func.isRequired,\n        data: PropTypes.object.isRequired,\n        docUID: PropTypes.string.isRequired,\n        orientation: PropTypes.string.isRequired,\n        user: PropTypes.object.isRequired,\n        replyInsights: PropTypes.array.isRequired,\n        isMobile: PropTypes.bool.isRequired,\n        viewportDimensions: PropTypes.object.isRequired,\n        updateInsight: PropTypes.func.isRequired,\n        setInsightViewerDialog: PropTypes.func.isRequired,\n        setSelectedInsight: PropTypes.func.isRequired,\n        settings: PropTypes.object.isRequired,\n    };\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            linkPromises: {},\n            links: {},\n            viewType: MarginaliaViewTypes.CONTENT_EXPANDED,\n            seeMoreCaption: false,\n        };\n    }\n\n    componentWillMount() {\n        //console.log(\"-----MarginaliaCard\");\n        let insight = {...this.props.data};\n\n        this.getLinksMetadata(insight.media.links);\n    }\n\n    render() {\n        const insight = {...this.props.data};\n        const isSelectionInsight = !isEmpty(insight.quote.box);\n        const isQuote = insight.media &&\n            Object.keys(insight.media.images).length === 0 &&\n            Object.keys(insight.media.sketches).length === 0 &&\n            Object.keys(insight.media.links).length === 0 &&\n            insight.media.text.length === 0;\n        let icons = [];\n\n        if (insight.media && insight.media.text.length > 0 && insight.question === QuestionStates.NOT_A_QUESTION) {\n            icons.push({\n                type: InsightTypes.TEXT,\n                icon: TextIcon,\n                color: ColorTypes.YELLOW\n            });\n        }\n\n        if (insight.media && insight.media.text.length > 0 && insight.question !== QuestionStates.NOT_A_QUESTION) {\n            icons.push({\n                type: InsightTypes.QUESTION,\n                icon: QuestionIcon,\n                color: ColorTypes.RED\n            });\n        }\n\n        if (insight.media && Object.keys(insight.media.images).length > 0) {\n            icons.push({\n                type: InsightTypes.IMAGE,\n                icon: ImageIcon,\n                color: ColorTypes.BLUE\n            });\n        }\n\n        if (insight.media && Object.keys(insight.media.sketches).length > 0) {\n            icons.push({\n                type: InsightTypes.SKETCH,\n                icon: SketchIcon,\n                color: ColorTypes.GREEN\n            });\n        }\n\n        if (insight.media && Object.keys(insight.media.links).length > 0) {\n            icons.push({\n                type: InsightTypes.LINK,\n                icon: LinkIcon,\n                color: ColorTypes.PURPLE\n            });\n        }\n\n        if (isQuote) {\n            icons.push({\n                type: InsightTypes.QUOTE,\n                icon: QuoteIcon,\n                color: ColorTypes.YELLOW\n            });\n        }\n\n        const capitalizeFirstLetter = str => str[0].toUpperCase() + str.slice(1);\n\n        let contextMenuItems = [\n            {\n                name: \"View\",\n                handleClick: () => {\n                    this.handleClick();\n                }\n            },\n            {\n                name: \"Get Link\",\n                handleClick: () => {\n                    this.props.addToClipboard(insight.media.text, this.getInsightLink());\n                    const message = `Added ${capitalizeFirstLetter(this.props.data.type)} Insight to your Clipboard.`;\n                    this.props.setSnackbar({\n                        active: true,\n                        message: message,\n                        duration: 3000\n                    });\n                }\n            }\n        ];\n\n        return (\n            <ThemeContext.Consumer>\n                {theme => {\n                    return (\n                        <Container\n                            id={`note=${insight.uid}`}\n                            viewType={this.state.viewType}\n                            hasQuestion={this.props.hasQuestion}\n                            isQuote={isQuote}\n                            onClick={this.handleClick}\n                            onMouseEnter={isSelectionInsight ? () => {this.setBoundingBox(true)} : this.props.handleHover.bind({}, true)}\n                            onMouseLeave={isSelectionInsight ? () => {this.setBoundingBox(false)} : this.props.handleHover.bind({}, false)}>\n                            <Head\n                                orientation={this.props.orientation}>\n                                <DetailsContainer\n                                    orientation={this.props.orientation}>\n                                    <AuthorAvatar\n                                        orientation={this.props.orientation}>\n                                        <UserProfileIcon\n                                            url={this.props.user.avatarURL}\n                                            hover={false} />\n                                    </AuthorAvatar>\n                                    {(this.state.viewType === MarginaliaViewTypes.DETAIL_EXPANDED ||\n                                    this.state.viewType === MarginaliaViewTypes.CONTENT_EXPANDED) &&\n                                        <MarginaliaDetails>\n                                            <AuthorName>\n                                                {this.props.user &&\n                                                this.props.user.name &&\n                                                this.props.user.username ?\n                                                    this.props.user.name.firstName\n                                                :\n                                                    \"User\"\n                                                }\n                                            </AuthorName>\n                                            <TimeAndVisibility>\n                                                <InsightTimestamp>\n                                                    {TimeBeforeFormat(insight.timestamp, true)}\n                                                </InsightTimestamp>\n                                                <VisibilityContainer>\n                                                    {VisibilityIcon({\n                                                        visibility: typeof insight.visibility === \"string\" ? insight.visibility : insight.visibility.type,\n                                                        primarycolor: theme.black,\n                                                        opacity: 0.38,\n                                                        hover: false\n                                                    })}\n                                                </VisibilityContainer>\n                                            </TimeAndVisibility>\n                                        </MarginaliaDetails>\n                                    }\n                                </DetailsContainer>\n                                {this.state.viewType === MarginaliaViewTypes.CONTENT_EXPANDED && !isQuote &&\n                                    <MarginaliaButtonContainer>\n                                        {\n                                            contextMenuItems.length > 0 &&\n                                            <More>\n                                                {GhostButton(MoreIcon)({\n                                                    width: 15,\n                                                    height: 15,\n                                                    handleClick: (e) => {\n                                                        e.stopPropagation();\n                                                        this.props.setContextMenu(\n                                                            true,\n                                                            e.clientX,\n                                                            e.clientY,\n                                                            contextMenuItems,\n                                                            \"basic\"\n                                                        )\n                                                    },\n                                                    primarycolor: theme.black,\n                                                    opacity: 0.38,\n                                                    padding: true,\n                                                    hover: true,\n                                                    cursor: \"pointer\"\n                                                })}\n                                            </More>\n                                        }\n                                        <MarginaliaButton\n                                            active={Object.keys(insight.replies).length > 0}\n                                            isMobile={this.props.isMobile}>\n                                            <ReplyIconContainer>\n                                                <SpeechBubbleIcon\n                                                    primarycolor={theme.black}\n                                                    opacity={0.38}\n                                                    hover={false} />\n                                            </ReplyIconContainer>\n                                            <ButtonFigure\n                                                color={theme.black}>\n                                                {Object.keys(insight.replies).length}\n                                            </ButtonFigure>\n                                        </MarginaliaButton>\n                                    </MarginaliaButtonContainer>\n                                }\n                            </Head>\n                            <Body\n                                viewType={this.state.viewType}\n                                isQuote={isQuote}>\n                                {this.state.viewType === MarginaliaViewTypes.CONTENT_EXPANDED && !isQuote ?\n                                        <React.Fragment>\n                                            {insight.media && Object.keys(insight.media.images).length > 0 &&\n                                                <InsightImageContainer>\n                                                    {Object.keys(insight.media.images).map((url, index, arr) => {\n                                                        return (\n                                                            <InsightImage\n                                                                key={url}\n                                                                marginRight={index + 1 !== arr.length}>\n                                                                <Image\n                                                                    src={url}\n                                                                    placeholder={() => (<ImageIcon\n                                                                        primarycolor={theme.darkGray}\n                                                                        hover={true}\n                                                                        opacity={1} />)}\n                                                                    placeholderHeight={60} />\n                                                            </InsightImage>\n                                                        );\n                                                    })}\n                                                </InsightImageContainer>\n                                            }\n                                            {insight.media && Object.keys(insight.media.sketches).length > 0 &&\n                                                <InsightSketchContainer>\n                                                    {Object.keys(insight.media.sketches).map((url, index, arr) => {\n                                                        return (\n                                                            <InsightSketch\n                                                                key={url}\n                                                                marginRight={index + 1 !== arr.length}>\n                                                                <Image\n                                                                    src={url}\n                                                                    placeholder={() => (<SketchIcon\n                                                                        primarycolor={theme.darkGray}\n                                                                        hover={true}\n                                                                        opacity={1} />)}\n                                                                    placeholderHeight={60} />\n                                                            </InsightSketch>\n                                                        );\n                                                    })}\n                                                </InsightSketchContainer>\n                                            }\n                                            {insight.media && Object.keys(insight.media.links).length > 0 &&\n                                                <InsightLinkContainer>\n                                                    {Object.keys(insight.media.links).map((url, index, arr) => {\n                                                            if (url in this.state.links) {\n                                                                const link = this.state.links[url];\n                                                                return (\n                                                                    <InsightLink\n                                                                        marginRight={index + 1 !== arr.length}\n                                                                        key={url}>\n                                                                        <LinkImage>\n                                                                            <Image\n                                                                                src={link.image}\n                                                                                placeholder={() => (<LinkIcon\n                                                                                    primarycolor={theme.darkGray}\n                                                                                    hover={true}\n                                                                                    opacity={1} />)}\n                                                                                placeholderHeight={60} />\n                                                                        </LinkImage>\n                                                                        <LinkContent>\n                                                                            <LinkTitle\n                                                                                href={url}\n                                                                                target={\"_blank\"}>\n                                                                                {link.title ?\n                                                                                    link.title.length > LINK_TITLE_THRESHOLD ?\n                                                                                        `${link.title.slice(0, LINK_TITLE_THRESHOLD)}...`\n                                                                                    :\n                                                                                        link.title\n                                                                                :\n                                                                                    url.length > LINK_TITLE_THRESHOLD ?\n                                                                                        `${url.slice(0, LINK_TITLE_THRESHOLD)}...`\n                                                                                    :\n                                                                                        url\n                                                                                }\n                                                                            </LinkTitle>\n                                                                            {link.description && link.description.length > 0 &&\n                                                                                <LinkDescription>\n                                                                                    {link.description.length > LINK_DESCRIPTION_THRESHOLD ?\n                                                                                        `${link.description.slice(0, LINK_DESCRIPTION_THRESHOLD)}...`\n                                                                                    :\n                                                                                        link.description\n                                                                                    }\n                                                                                </LinkDescription>\n                                                                            }\n                                                                        </LinkContent>\n                                                                    </InsightLink>\n                                                                );\n                                                            } else {\n                                                                return (\n                                                                    <AttachmentPlaceholder\n                                                                        key={url}>\n                                                                        <Loader/>\n                                                                    </AttachmentPlaceholder>\n                                                                );\n                                                            }\n                                                        })\n                                                    }\n                                                </InsightLinkContainer>\n                                            }\n                                            {insight.media && insight.media.text.length > 0 &&\n                                                <InsightText\n                                                    orientation={this.props.orientation}\n                                                    hasBorder={true}>\n                                                    {insight.media.text &&\n                                                    (insight.media.text.length > SEE_MORE_TEXT_THRESHOLD ||\n                                                    insight.media.text.split('\\n').length - 1 > SEE_MORE_LINE_THRESHOLD ||\n                                                    insight.media.text.split('\\r').length - 1 > SEE_MORE_LINE_THRESHOLD) &&\n                                                    !this.state.seeMoreCaption ?\n                                                        <React.Fragment>\n                                                            {`${\n                                                                insight.media.text.split('\\r').length - 1 > SEE_MORE_LINE_THRESHOLD ?\n                                                                    insight.media.text.split('\\r').slice(0, SEE_MORE_LINE_THRESHOLD - insight.media.text.split('\\r').length).join(\"\\r\")\n                                                                :\n                                                                    insight.media.text.split('\\n').length - 1 > SEE_MORE_LINE_THRESHOLD ?\n                                                                        insight.media.text.split('\\n').slice(0, SEE_MORE_LINE_THRESHOLD - insight.media.text.split('\\n').length).join(\"\\n\")\n                                                                    :\n                                                                        insight.media.text.slice(0, SEE_MORE_TEXT_THRESHOLD)\n                                                            }... `}\n                                                            <SeeMore\n                                                                onClick={this.handleSeeMoreCaption}>\n                                                                See More\n                                                            </SeeMore>\n                                                        </React.Fragment>\n                                                    :\n                                                        insight.media.text\n                                                    }\n                                                </InsightText>\n                                            }\n                                            {insight.question !== QuestionStates.NOT_A_QUESTION &&\n                                                <ResponseContainer>\n                                                    <ResponseHeader>\n                                                        Status:\n                                                    </ResponseHeader>\n                                                    {this.props.currentUser.uid !== insight.user ?\n                                                        <ResponseStatus\n                                                            resolved={insight.question === QuestionStates.RESOLVED_QUESTIONS}>\n                                                            {\n                                                                insight.question === QuestionStates.RESOLVED_QUESTIONS ?\n                                                                    \"Resolved\"\n                                                                :\n                                                                    \"Unresolved\"\n                                                            }\n                                                        </ResponseStatus>\n                                                    :\n                                                        <InputContainer\n                                                            data-tooltip\n                                                            data-tooltip-at={\"top\"}\n                                                            data-info={insight.question === QuestionStates.RESOLVED_QUESTIONS ?\n                                                                \"Resolved\"\n                                                            :\n                                                                \"Unresolved\"}\n                                                            height={\"auto\"}\n                                                            direction={\"row\"}>\n                                                            <ToggleInput\n                                                                size={\"small\"}\n                                                                resolved={insight.question === QuestionStates.RESOLVED_QUESTIONS}\n                                                                checkedThumbColor={theme.green}\n                                                                uncheckedThumbColor={theme.red}\n                                                                trackBackgroundColor={theme.black}\n                                                                handleToggleInput={this.handleQuestionResolution} />\n                                                      </InputContainer>\n                                                    }\n                                                </ResponseContainer>\n                                            }\n                                        </React.Fragment>\n                                    :\n                                        <IconsContainer>\n                                            {icons.map((iconObj, index) => {\n                                                let Icon = iconObj.icon;\n                                                return (\n                                                    <InsightType\n                                                        key={`icon-${index}`}\n                                                        isQuote={isQuote}\n                                                        orientation={this.props.orientation}\n                                                        type={iconObj.type}>\n                                                        <Icon\n                                                            primarycolor={theme[iconObj.color]}\n                                                            hover={false}\n                                                            opacity={1} />\n                                                    </InsightType>\n                                                );\n                                            })}\n                                        </IconsContainer>\n                                }\n                            </Body>\n                            {(() => {\n                                if (isSelectionInsight) {\n                                    const insightUID = this.props.data.uid;\n                                    const pageDimensions = this.props.pageDimensions;\n                                    const selection = insight.quote.box.selection;\n                                    const actualCanvas = insight.quote.box.canvas.actual;\n                                    const boundBox = {\n                                        x: pageDimensions.width * (selection.upperLeft.x/actualCanvas.width),\n                                        y: pageDimensions.height * (selection.upperLeft.y/actualCanvas.height),\n                                        width:  pageDimensions.width * (selection.dimensions.width/actualCanvas.width),\n                                        height: pageDimensions.height * (selection.dimensions.height/actualCanvas.height),\n                                    };\n                                    const shouldDisplayInsight = !!this.props.stagedMarginalia[insightUID];\n                                    return (\n                                        <BoundingBox\n                                            active={shouldDisplayInsight}\n                                            data-insight-uid={insightUID}\n                                            pageDimensions={this.props.pageDimensions}\n                                            top={boundBox.y}\n                                            left={boundBox.x}\n                                            width={boundBox.width}\n                                            height={boundBox.height} />\n                                    );\n                                }\n                            })()}\n                        </Container>\n                    );\n                }}\n            </ThemeContext.Consumer>\n        )\n    }\n\n    componentDidMount() {\n        //console.log(\"+++++MarginaliaCard\");\n        let insight = {...this.props.data};\n        if (Object.keys(insight.media.links).length > 0) {\n            this.getLinksMetadata(insight.media.links);\n        }\n\n        let viewType = this.determineViewType(this.props.viewportDimensions, this.props.settings);\n\n        this.setState({\n            viewType: viewType,\n        });\n\n        if (this.props.handleOnLoad) {\n            this.props.handleOnLoad();\n        }\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return true;\n\n    }\n\n    componentWillReceiveProps(nextProps) {\n        // Check if has Question\n        if (!isEmpty(nextProps.replyInsights)) {\n            let hasQuestion = nextProps.data.question === QuestionStates.UNRESOLVED_QUESTION;\n            nextProps.replyInsights.reduce((hasQuestion, reply) => {\n                return hasQuestion || reply.question === QuestionStates.UNRESOLVED_QUESTION;\n            });\n\n            this.setState({\n                hasQuestion: hasQuestion\n            });\n        }\n\n        // If Change in Viewport\n        if (!isEqual(this.props.viewportDimensions,nextProps.viewportDimensions)) {\n            let viewType = this.determineViewType(nextProps.viewportDimensions, nextProps.settings);\n            this.setState({\n                viewType: viewType\n            });\n        }\n\n        // If Change in Font\n        if (this.props.settings.fontSize != nextProps.settings.fontSize) {\n            let viewType = this.determineViewType(nextProps.viewportDimensions, nextProps.settings);\n            this.setState({\n                viewType: viewType\n            });\n        }\n\n        // Show Link Metadata\n        this.getLinksMetadata(nextProps.data.media.links);\n    }\n\n    componentWillUnmount() {\n        forOwn(this.state.linkPromises, cancelablePromise => cancelablePromise.cancel());\n    }\n\n    // ========== Methods ===========\n\n    getInsightLink = () => {\n        const link = `${location.origin}${documentInsightRoute(this.props.data.doc, this.props.data.uid)}`;\n        // TODO: implement more sophisticated links for users and different privacy settings\n        return link;\n    };\n\n    getLinksMetadata = (urls) => {\n        const urlKeys = Object.keys(urls);\n        if (!urlKeys.length) { return }\n        urlKeys\n            .forEach(url => {\n                const cancelablePromise = extractURLMetaTags(url);\n                this.state.linkPromises[url] = cancelablePromise;\n                cancelablePromise.then(metadata => {\n                        if (!this.state.linkPromises[url].isCanceled) {\n                            this.setState({\n                                links: {\n                                    ...this.state.links,\n                                    [url]: {...metadata}\n                                }\n                            });\n                        }\n                    });\n            });\n    };\n\n    handleQuestionResolution = (e) => {\n        e.stopPropagation();\n        const newQuestionState = this.props.data.question === QuestionStates.RESOLVED_QUESTIONS ? QuestionStates.UNRESOLVED_QUESTION : QuestionStates.RESOLVED_QUESTIONS;\n        this.props.updateInsight(this.props.data.uid, {question: newQuestionState});\n        const message = `Your Question Insight has been set to ${this.props.data.question === QuestionStates.RESOLVED_QUESTIONS ? \"Unresolved\" : \"Resolved\"}.`;\n        this.props.setSnackbar({\n            active: true,\n            message: message,\n            duration: 6000\n        });\n    };\n\n    handleClick = () => {\n        this.props.setInsightViewerDialog({active: true});\n        const containerIndex = this.props.bucketIndex === undefined\n            ? this.props.paragraphIndex\n            : this.props.bucketIndex;\n        this.props.setSelectedInsight(this.props.data.uid, containerIndex);\n    };\n\n    handleSeeMoreCaption = (e) => {\n        e.stopPropagation();\n        this.setState({\n            seeMoreCaption: true\n        });\n    };\n\n    setBoundingBox = (state) => {\n        const insight = this.props.data;\n        const marginalia = {[insight.uid]: insight};\n        this.props.setStagedMarginalia(marginalia, state);\n    }\n\n    determineViewType = (viewportDimensions, settings) => {\n        if (viewportDimensions.width > 1200 || settings.fontSize < 18) {\n            return MarginaliaViewTypes.CONTENT_EXPANDED;\n        } else if (viewportDimensions.width > 1050 || settings.fontSize < 20) {\n            return MarginaliaViewTypes.DETAIL_EXPANDED;\n        } else {\n            return MarginaliaViewTypes.ABRIDGED;\n        }\n    }\n}\n\n// ============= Styled Components ==============\n\nconst Container = styled.div`\n    display: flex;\n    flex-direction: ${props => props.viewType === MarginaliaViewTypes.CONTENT_EXPANDED && !props.isQuote ? \"column\" : \"row\"};\n    align-items: flex-start;\n    background    : ${props => props.hasQuestion ? themeColors.midRed : props.theme.white};\n    max-width: 100%;\n    box-shadow    : 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n    margin        : 5px 0px;\n    padding: 10px;\n    border-radius : 5px;\n    transition    : box-shadow 0.3s;\n    cursor: pointer;\n\n    &:hover {\n        box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);\n    }\n`;\n\nconst MarginaliaSignature = styled.div`\n    display: inline-flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n`;\n\nconst Head = styled.div`\n    display: flex;\n    flex-direction: ${props => props.orientation === \"left\" ? \"row\" : \"row-reverse\"};\n    justify-content: space-between;\n    width: 100%;\n`;\n\nconst DetailsContainer = styled.div`\n    display: flex;\n    flex-direction: ${props => props.orientation === \"left\" ? \"row\" : \"row-reverse\"};\n`;\n\nconst Body = styled.div`\n    display: inline-block;\n    margin-top: ${props => props.viewType === MarginaliaViewTypes.CONTENT_EXPANDED && !props.isQuote ? \"5px\" : \"0px\"};\n`;\n\nconst MarginaliaDetails = styled.div`\n    display        : flex;\n    flex-direction: column;\n    margin-left: ${props => props.orientation === \"left\" ? \"0px\" : \"5px\"};\n    margin-right: ${props => props.orientation === \"left\" ? \"5px\" : \"0px\"};\n    justify-content: space-between;\n    min-height: 32px;\n`;\n\nconst AuthorAvatar = styled.div`\n    display: inline-block;\n    width  : 32px;\n    height : 32px;\n    margin-right: ${props => props.orientation === \"left\" ? \"5px\" : \"0px\"};\n    margin-left: ${props => props.orientation === \"left\" ? \"0px\" : \"5px\"};\n\n    @media (max-width: 800px) {\n        height: 25px;\n        width: 25px;\n    }\n`;\n\nconst TimeAndVisibility = styled.div`\n    display: inline-flex;\n    flex-direction: row;\n    align-items: center;\n`;\n\nconst AuthorName = styled.h4`\n    display: inline-block;\n    opacity: 0.87;\n    margin: 0;\n    font-size  : 0.8em;\n    font-weight: 600;\n    color: ${props => props.theme.black};\n    transition: color 0.3s;\n`;\n\nconst InsightTimestamp = styled.span`\n    display: inline-block;\n    font-size: 0.7em;\n    line-height: 1.05em;\n    color: ${props => props.theme.black};\n    opacity: 0.87;\n`;\n\nconst VisibilityContainer = styled.div`\n    display        : inline-flex;\n    align-items    : center;\n    justify-content: center;;\n    width          : 15px;\n    height         : 15px;\n    margin-left: 5px;\n    transition: background 0.3s;\n    border-radius: 2px;\n\n    &:hover {\n        background: ${props => props.editable ?\n            props.theme.lightGray\n        :\n            \"none\"\n        };\n    }\n`;\n\nconst IconsContainer = styled.ul`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n\n    & > li:first-child {\n        margin-left: 10px;\n    }\n`;\n\nconst InsightType = styled.li`\n    width: ${props => props.type === InsightTypes.QUOTE ? \"32px\" : \"25px\"};\n    height: 32px;\n    margin-left: 5px;\n\n    @media (max-width: 800px) {\n        width: 20px;\n        height: 25px;\n        margin-left: 0px;\n    }\n`;\n\nconst More = styled.div`\n    display        : flex;\n    align-items    : center;\n    justify-content: center;\n    width          : 15px;\n    height         : 15px;\n    transform: rotate(90deg);\n`;\n\nconst MarginaliaButtonContainer = styled.div`\n    display: inline-flex;\n    flex-direction: column;\n    justify-content: space-between;\n    align-items: center;\n    width: 30px;\n    height: 32px;\n`;\n\nconst MarginaliaButton = styled.div`\n    display: ${props => props.active ? \"flex\" : \"none\"};\n    align-items: center;\n    justify-content: center;\n    width: 30px;\n    height: 12px;\n`;\n\nconst ReplyIconContainer = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 15px;\n    height: 15px;\n    padding: 1px;\n`;\n\nconst ButtonContainer = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-around;\n    width: ${props => `${props.width}px`};\n    height: ${props => `${props.height}px`};\n`;\n\nconst ButtonIcon = styled.div`\n    width: ${props => `${props.height}px`};\n    height: ${props => `${props.height}px`};\n    padding: 15px;\n`;\n\nconst ButtonFigure = styled.h4`\n    color: ${props => props.color};\n    font-weight: 600;\n    font-size: 0.7em;\n    line-height: 0.7em;\n    opacity: 0.87;\n    margin: 0;\n    margin-left: 2px;\n    white-space: nowrap;\n`;\n\nconst InsightContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n`;\n\nconst InsightText = styled.p`\n    font-size: 0.8em;\n    font-weight: 400;\n    color: ${props => props.theme.black};\n    line-height: 1.2em;\n    margin: 0;\n    margin-top: 10px;\n    padding: ${props => props.hasBorder ? \"5px\" : \"0px\"};\n    border: ${props => props.hasBorder ? `2px solid ${props.theme.lightGray}` : \"none\"};\n    border-radius: 5px;\n    white-space: pre-wrap;\n`;\n\nconst InsightImageContainer = styled.div`\n    margin-bottom: 0px;\n`;\n\nconst InsightImage = styled.div`\n    display: inline-block;\n    border-radius: 5px;\n    overflow: hidden;\n    height: ${props => props.selected ? \"auto\" : \"60px\"};\n    width: ${props => props.selected ? \"100%\" : \"auto\"};\n    box-shadow: 0 0.5px 1.5px rgba(0,0,0,.12), 0 0.5px 1px rgba(0,0,0,.24);\n    margin-top: 5px;\n    margin-right: ${props => props.marginRight ? \"5px\" : \"0px\"};\n    cursor: ${props => props.selected ? \"default\" : \"pointer\"};\n    transition: width 0.3s, height 0.3s, box-shadow 0.3s;\n\n    & img {\n        height: ${props => props.selected ? \"auto\" : \"100%\"};\n        width: ${props => props.selected ? \"100%\" : \"auto\"};\n        border-radius: 2.5px;\n    }\n`;\n\nconst AttachmentPlaceholder = styled.div`\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    width: 115px;\n    min-height: 25px;\n`;\n\nconst InsightLinkContainer = styled.div`\n`;\n\nconst InsightLink = styled.div`\n    display: inline-flex;\n    flex-direction: row;\n    position: relative;\n    height: 60px;\n    margin: 0;\n    margin-top: 5px;\n    margin-right: ${props => props.marginRight ? \"5px\" : \"0px\"};\n    border-radius: 5px;\n    box-shadow    : 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n    border-radius: 5px;\n    overflow: hidden;\n`;\n\nconst LinkContent = styled.div`\n    padding: 10px;\n    background: ${props => props.theme.white};\n`;\n\nconst LinkImage = styled.div`\n    display: inline-block;\n    height: 60px;\n    & img {\n        height: 100%;\n        width: auto;\n    }\n`;\n\nconst LinkTitle = styled.a`\n    display: block;\n    color: ${props => props.theme.black};\n    font-size: 0.8em;\n    line-height: 0.8em;\n    font-weight: 600;\n    word-break: break-all;\n\n    &:hover {\n        transform: scale(1.01);\n        color: ${props => props.theme.lightPurple};\n    }\n`;\n\nconst LinkDescription = styled.p`\n    color: ${props => props.theme.gray};\n    font-size: 0.6em;\n    line-height: 0.6em;\n    font-weight: 300;\n    opacity: 1;\n    margin: 0;\n    margin-top: 10px;\n`;\n\nconst InsightSketchContainer = styled.div`\n`;\n\nconst InsightSketch = styled.div`\n    display: inline-block;\n    border-radius: 5px;\n    overflow: hidden;\n    height: ${props => props.selected ? \"auto\" : \"60px\"};\n    width: ${props => props.selected ? \"100%\" : \"auto\"};\n    box-shadow: 0 0.5px 1.5px rgba(0,0,0,.12), 0 0.5px 1px rgba(0,0,0,.24);\n    margin-top: 5px;\n    margin-right: ${props => props.marginRight ? \"5px\" : \"0px\"};\n    cursor: ${props => props.selected ? \"default\" : \"pointer\"};\n    transition: width 0.3s, height 0.3s, box-shadow 0.3s;\n\n    & img {\n        height: ${props => props.selected ? \"auto\" : \"100%\"};\n        width: ${props => props.selected ? \"100%\" : \"auto\"};\n        border-radius: 2.5px;\n    }\n`;\n\nconst TextInputContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst TextArea = styled.textarea`\n    border-radius: 5px;\n    border: none;\n    appearance: none;\n    outline: 0;\n    outline: none;\n    outline-width: 0;\n    padding: 6px 10px;\n    width: 200px;\n    height: 60px;\n    background: ${props => props.theme.lightGray};\n    font-size: 0.8em;\n    line-height: 1.3em;\n    box-shadow: inset 0 2px 5px rgba(0,0,0,0.22);\n    resize: none;\n`;\n\nconst ResponseContainer = styled.div`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n    margin: 5px 0px;\n    margin-bottom: 0px;\n    font-size: 0.8em;\n`;\n\nconst ResponseHeader = styled.div`\n    font-weight: 600;\n    line-height: 0.8em;\n`;\n\nconst ResponseStatus = styled.div`\n    margin-left: 10px;\n    line-height: 0.8em;\n    color: ${props => props.resolved ? props.theme.green : props.theme.red};\n`;\n\nconst InputContainer = styled.div`\n    display: flex;\n    flex-direction: ${props => props.direction};\n    align-items: center;\n    justify-content: space-around;\n    height: ${props => typeof props.height === \"number\" ? `${props.height}px` : props.height};\n    margin-left: 5px;\n`;\n\nconst TextColor = styled.span`\n    color: ${props => props.theme[props.color]};\n`;\n\nconst VisibilityTriangleContainer = styled.div`\n    margin-left: 5px;\n`;\n\nconst SeeMore = styled.span`\n    color: ${props => props.theme.lightPurple};\n    font-weight: 500;\n    padding: 10px;\n    transition: color 0.3s;\n    cursor: pointer;\n\n    &:hover {\n        color: ${props => props.theme.purple};\n    }\n`;\n\nconst BoundingBox = styled.div`\n    position: absolute;\n    top: ${props => `${props.top}px`};\n    left: ${props => `${props.left}px`};\n    width: ${props => `${props.width}px`};\n    height: ${props => `${props.height}px`};\n    visibility: ${props => props.active ? \"visible\" : \"hidden\"};\n    opacity: ${props => props.active ? \"1\" : \"0\"};\n    border-radius: 5px;\n    transform: ${props => `translateX(-${props.pageDimensions.width}px)`};\n    background: rgba(101, 38, 109, 0.38);\n    transition: opacity 0.3s, visibility 0.3s;\n`;\n\nconst LINK_TITLE_THRESHOLD = 35;\nconst LINK_DESCRIPTION_THRESHOLD = 50;\nconst SEE_MORE_TEXT_THRESHOLD = 200;\nconst SEE_MORE_LINE_THRESHOLD = 4;\n\nexport default compose(\n    connect(\n        mapStateToProps,\n        mapDispatchToProps\n    ),\n    firestoreConnect((props) => {\n        let queries = [];\n        if (props.currentUser && props.currentUser.uid) {\n            const currentUserUID = props.currentUser.uid;\n            const docUID = props.data.doc;\n            const insightCreator = props.data.user;\n            const insightUID = props.data.uid;\n\n            let replyQueries = insightsQueryFromCondition(\n                currentUserUID,\n                ['parent', '==', insightUID],\n                InsightVariantTypes.REPLY\n            );\n\n            queries = [\n                ...replyQueries,\n                {\n                    collection: USERS_COLLECTION,\n                    doc: insightCreator,\n                    storeAs: `${USERS_COLLECTION}.${insightCreator}`,\n                },\n                {\n                    collection: DOCUMENTS_COLLECTION,\n                    doc: docUID,\n                    storeAs: `${DOCUMENTS_COLLECTION}.${docUID}`\n                }\n            ]\n        }\n\n        return queries;\n    })\n)(MarginaliaCard);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/components/MarginaliaCard.js	(date 1543432850000)
+++ app/components/MarginaliaCard.js	(date 1543452188338)
@@ -61,60 +61,40 @@
     getInsightsCollectionFromStore
 } from '../actions/Utils';
 
-// Constants
-const USERS_COLLECTION = firestoreUtils.collections.users.NAME;
-const INSIGHTS_COLLECTION = firestoreUtils.collections.insights.NAME;
-const DOCUMENTS_COLLECTION = firestoreUtils.collections.documents.NAME;
+// Custom Modules
 import InsightTypes         from '../constants/insightTypes';
 import ColorTypes           from '../constants/colorTypes';
 import MarginaliaViewTypes  from '../constants/marginaliaViewTypes';
-import InsightVariantTypes  from "../constants/insightVariantTypes";
 import QuestionStates       from '../constants/questionStates';
 
+// Constants
+const USERS_COLLECTION = firestoreUtils.collections.users.NAME;
+
 // ============= Redux =============
 
 const mapStateToProps = (state, props) => {
     const firestoreData = state.firestore.data;
-    const currentUserUID = state.profile.currentUser.metadata.uid;
-    const docUID = props.data.doc;
     const insightsCollection = getInsightsCollectionFromStore(state);
-    const documentsCollection = !!firestoreData && firestoreData[DOCUMENTS_COLLECTION];
     const usersCollection = !!firestoreData && firestoreData[USERS_COLLECTION];
-    let replyInsights = [];
-    let activeDoc = {};
-
-    if (insightsCollection && currentUserUID) {
-        Object.keys(props.data.replies).forEach(uid => {
-            const insight = insightsCollection[uid];
-            if (insight && insightShouldBeVisibleToViewingUser(insight, currentUserUID, InsightVariantTypes.REPLY)) {
-                replyInsights.push(insightsCollection[uid]);
-            }
-        });
-    }
-
-    if (documentsCollection &&
-        documentsCollection[docUID]) {
-        activeDoc = {...documentsCollection[docUID]};
-    }
+    const data = (props.insightUID && insightsCollection && insightsCollection[props.insightUID]) || {};
 
     let user = {};
-    if (props.data.user !== "Author"
+    if (data.user !== "Author"
         && usersCollection
-        && usersCollection[props.data.user]) {
-        user = {...usersCollection[props.data.user]};
+        && usersCollection[data.user]) {
+        user = {...usersCollection[data.user]};
     }
 
     return {
         user,
-        replyInsights,
         history: state.app.router.history,
+        data,
         isMobile: state.app.isMobile,
         viewportDimensions: state.app.viewportDimensions,
         currentUser: state.profile.currentUser.metadata,
         viewer: state.insights.viewer,
-        hasQuestion: props.data.question === QuestionStates.UNRESOLVED_QUESTION,
-        stagedMarginalia: state.insights.stagedMarginalia.selections,
-        activeDoc,
+        hasQuestion: data.question === QuestionStates.UNRESOLVED_QUESTION,
+        stagedMarginalia: state.insights.stagedMarginalia,
         settings: state.profile.settings
     };
 };
@@ -139,11 +119,11 @@
 
     static propTypes = {
         setContextMenu: PropTypes.func.isRequired,
+        insightUID: PropTypes.string.isRequired,
         data: PropTypes.object.isRequired,
         docUID: PropTypes.string.isRequired,
         orientation: PropTypes.string.isRequired,
         user: PropTypes.object.isRequired,
-        replyInsights: PropTypes.array.isRequired,
         isMobile: PropTypes.bool.isRequired,
         viewportDimensions: PropTypes.object.isRequired,
         updateInsight: PropTypes.func.isRequired,
@@ -164,13 +144,11 @@
 
     componentWillMount() {
         //console.log("-----MarginaliaCard");
-        let insight = {...this.props.data};
-
-        this.getLinksMetadata(insight.media.links);
+        this.getLinksMetadata(this.props.data.media.links);
     }
 
     render() {
-        const insight = {...this.props.data};
+        const insight = this.props.data;
         const isSelectionInsight = !isEmpty(insight.quote.box);
         const isQuote = insight.media &&
             Object.keys(insight.media.images).length === 0 &&
@@ -249,7 +227,7 @@
                 }
             }
         ];
-
+        console.log('MarginaliaCard render');
         return (
             <ThemeContext.Consumer>
                 {theme => {
@@ -260,8 +238,14 @@
                             hasQuestion={this.props.hasQuestion}
                             isQuote={isQuote}
                             onClick={this.handleClick}
-                            onMouseEnter={isSelectionInsight ? () => {this.setBoundingBox(true)} : this.props.handleHover.bind({}, true)}
-                            onMouseLeave={isSelectionInsight ? () => {this.setBoundingBox(false)} : this.props.handleHover.bind({}, false)}>
+                            onMouseEnter={isSelectionInsight ? () => {this.setBoundingBox(true)} : () => {
+                                console.log('MarginaliaCard onMouseEnter');
+                                this.props.handleHover(true)
+                            }}
+                            onMouseLeave={isSelectionInsight ? () => {this.setBoundingBox(false)} : () => {
+                                console.log('MarginaliaCard onMouseLeave');
+                                // this.props.handleHover(false)
+                            }}>
                             <Head
                                 orientation={this.props.orientation}>
                                 <DetailsContainer
@@ -542,7 +526,7 @@
                                         width:  pageDimensions.width * (selection.dimensions.width/actualCanvas.width),
                                         height: pageDimensions.height * (selection.dimensions.height/actualCanvas.height),
                                     };
-                                    const shouldDisplayInsight = !!this.props.stagedMarginalia[insightUID];
+                                    const shouldDisplayInsight = !!this.props.stagedMarginalia.selections[insightUID];
                                     return (
                                         <BoundingBox
                                             active={shouldDisplayInsight}
@@ -580,24 +564,7 @@
         }
     }
 
-    shouldComponentUpdate(nextProps, nextState) {
-        return true;
-
-    }
-
     componentWillReceiveProps(nextProps) {
-        // Check if has Question
-        if (!isEmpty(nextProps.replyInsights)) {
-            let hasQuestion = nextProps.data.question === QuestionStates.UNRESOLVED_QUESTION;
-            nextProps.replyInsights.reduce((hasQuestion, reply) => {
-                return hasQuestion || reply.question === QuestionStates.UNRESOLVED_QUESTION;
-            });
-
-            this.setState({
-                hasQuestion: hasQuestion
-            });
-        }
-
         // If Change in Viewport
         if (!isEqual(this.props.viewportDimensions,nextProps.viewportDimensions)) {
             let viewType = this.determineViewType(nextProps.viewportDimensions, nextProps.settings);
@@ -607,7 +574,7 @@
         }
 
         // If Change in Font
-        if (this.props.settings.fontSize != nextProps.settings.fontSize) {
+        if (this.props.settings.fontSize !== nextProps.settings.fontSize) {
             let viewType = this.determineViewType(nextProps.viewportDimensions, nextProps.settings);
             this.setState({
                 viewType: viewType
@@ -622,6 +589,19 @@
         forOwn(this.state.linkPromises, cancelablePromise => cancelablePromise.cancel());
     }
 
+    shouldComponentUpdate(nextProps, nextState) {
+        const insightUID = this.props.data.uid;
+        const wasStaged = this.props.stagedMarginalia.highlights[insightUID]
+            || this.props.stagedMarginalia.selections[insightUID];
+        const isStaged = nextProps.stagedMarginalia.highlights[insightUID]
+            || nextProps.stagedMarginalia.selections[insightUID];
+        console.log('shouldComponentUpdate', insightUID, this.props.stagedMarginalia, nextProps.stagedMarginalia);
+        if (wasStaged || isStaged) {
+            return false
+        }
+        return true;
+    }
+
     // ========== Methods ===========
 
     getInsightLink = () => {
@@ -681,7 +661,7 @@
         const insight = this.props.data;
         const marginalia = {[insight.uid]: insight};
         this.props.setStagedMarginalia(marginalia, state);
-    }
+    };
 
     determineViewType = (viewportDimensions, settings) => {
         if (viewportDimensions.width > 1200 || settings.fontSize < 18) {
@@ -714,13 +694,6 @@
     }
 `;
 
-const MarginaliaSignature = styled.div`
-    display: inline-flex;
-    flex-direction: row;
-    justify-content: space-between;
-    align-items: center;
-`;
-
 const Head = styled.div`
     display: flex;
     flex-direction: ${props => props.orientation === "left" ? "row" : "row-reverse"};
@@ -863,20 +836,6 @@
     padding: 1px;
 `;
 
-const ButtonContainer = styled.div`
-    display: flex;
-    align-items: center;
-    justify-content: space-around;
-    width: ${props => `${props.width}px`};
-    height: ${props => `${props.height}px`};
-`;
-
-const ButtonIcon = styled.div`
-    width: ${props => `${props.height}px`};
-    height: ${props => `${props.height}px`};
-    padding: 15px;
-`;
-
 const ButtonFigure = styled.h4`
     color: ${props => props.color};
     font-weight: 600;
@@ -888,11 +847,6 @@
     white-space: nowrap;
 `;
 
-const InsightContainer = styled.div`
-    display: flex;
-    flex-direction: column;
-`;
-
 const InsightText = styled.p`
     font-size: 0.8em;
     font-weight: 400;
@@ -1015,29 +969,6 @@
     }
 `;
 
-const TextInputContainer = styled.div`
-    display: flex;
-    justify-content: center;
-    align-items: center;
-`;
-
-const TextArea = styled.textarea`
-    border-radius: 5px;
-    border: none;
-    appearance: none;
-    outline: 0;
-    outline: none;
-    outline-width: 0;
-    padding: 6px 10px;
-    width: 200px;
-    height: 60px;
-    background: ${props => props.theme.lightGray};
-    font-size: 0.8em;
-    line-height: 1.3em;
-    box-shadow: inset 0 2px 5px rgba(0,0,0,0.22);
-    resize: none;
-`;
-
 const ResponseContainer = styled.div`
     display: flex;
     flex-direction: row;
@@ -1068,14 +999,6 @@
     margin-left: 5px;
 `;
 
-const TextColor = styled.span`
-    color: ${props => props.theme[props.color]};
-`;
-
-const VisibilityTriangleContainer = styled.div`
-    margin-left: 5px;
-`;
-
 const SeeMore = styled.span`
     color: ${props => props.theme.lightPurple};
     font-weight: 500;
@@ -1114,30 +1037,15 @@
     ),
     firestoreConnect((props) => {
         let queries = [];
+
         if (props.currentUser && props.currentUser.uid) {
-            const currentUserUID = props.currentUser.uid;
-            const docUID = props.data.doc;
             const insightCreator = props.data.user;
-            const insightUID = props.data.uid;
-
-            let replyQueries = insightsQueryFromCondition(
-                currentUserUID,
-                ['parent', '==', insightUID],
-                InsightVariantTypes.REPLY
-            );
-
             queries = [
-                ...replyQueries,
                 {
                     collection: USERS_COLLECTION,
                     doc: insightCreator,
                     storeAs: `${USERS_COLLECTION}.${insightCreator}`,
                 },
-                {
-                    collection: DOCUMENTS_COLLECTION,
-                    doc: docUID,
-                    storeAs: `${DOCUMENTS_COLLECTION}.${docUID}`
-                }
             ]
         }
 
Index: app/actions/ReadingPageActions.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Documents\nimport {\n    SHARE_DOCUMENT,\n    RESET_UNLOADED_READING_PAGE_BUCKET,\n    UPDATE_UNLOADED_PAGES_BUCKET_INDEX,\n    NAVIGATE_TO_QUOTE_CONTEXT,\n    UNSTAGE_ALL_HIGHLIGHT_MARGINALIA,\n    SET_BUCKET_INDEX_2_INSIGHTS,\n    SET_DOCUMENT_FONT_NAME,\n    SET_DOCUMENT_FONT_SIZE,\n    SET_NIGHT_MODE,\n    SET_PAGE_LAYOUT,\n    SET_QUOTE_PERSISTENCE,\n    CLEAR_BUCKET_INDEX_2_INSIGHTS,\n} from '../constants/actionTypes';\n\n// ActionTypes\nimport {\n    SET_SKETCH,\n    UPDATE_INSIGHT,\n    DELETE_INSIGHT,\n    SET_NEW_INSIGHT_DIALOG,\n    SET_SELECTION_HIGHLIGHT_INSIGHT_DATA,\n    SET_INSIGHT_VIEWER_DIALOG,\n    SET_SELECTED_INSIGHT,\n    STAGE_MARGINALIA,\n    UNSTAGE_MARGINALIA,\n    SET_DOCUMENT_STYLE_DIALOG,\n    SET_READING_PAGE_INSIGHT_DIALOG,\n    SET_READING_PAGE_SEARCH_DIALOG,\n    SHOW_INSIGHTS,\n    SET_INSIGHT_FILTER,\n    SET_AUTO_NIGHT_MODE,\n    SET_DAILY_EMAIL_SUMMARY,\n    SET_EMAIL_PER_NOTIFICATION,\n} from '../constants/actionTypes';\n\n// APIs\nimport firebase                         from 'firebase';\nimport {\n    isEmpty,\n    isEqual,\n    range,\n    uniq,\n    pickBy,\n    mapValues\n} from 'lodash';\n\nimport firestoreUtils from '../../functions/utils/Firestore';\n\n// Actions\nimport {\n    isHighlightInsight,\n    isSelectionInsight,\n    getInsightsCollectionFromStore,\n} from './Utils';\n\n// Custom Modules\nimport {InsightCRUDer}                      from './Insights/InsightCRUDer';\nimport InsightVariantTypes                  from '../constants/insightVariantTypes';\nimport {DocumentCRUDer}                     from './Documents/DocumentCRUDer';\nimport {HighlightInsight, SelectionInsight} from \"../data-structures/Insight\";\nimport QuestionStates                       from \"../constants/questionStates\";\n\n// Constants\nconst firestore = firebase.firestore();\nconst USERS_COLLECTION = firestoreUtils.collections.users.NAME;\nconst DOCUMENTS_COLLECTION = firestoreUtils.collections.documents.NAME;\nconst USERS_DOCUMENT_COLLECTION = firestoreUtils.collections.users.documents.NAME;\n\nexport const shareDocument = doc => ({\n    type: SHARE_DOCUMENT,\n    payload: doc\n});\n\nexport const setNewInsightDialog = (data) => ({\n    type: SET_NEW_INSIGHT_DIALOG,\n    payload: data\n});\n\nexport const setSelectionOrHighlightInsightData = data => ({\n    type: SET_SELECTION_HIGHLIGHT_INSIGHT_DATA,\n    payload: data\n});\n\nexport const setSelectedInsight = (insightUID, paragraphIndex) => {\n    return {\n        type: SET_SELECTED_INSIGHT,\n        payload: {\n            insightUID,\n            paragraphIndex,\n        }\n    };\n};\n\nexport const showInsights = state => ({\n    type: SHOW_INSIGHTS,\n    payload: state\n});\n\nexport const setInsightViewerDialog = data => {\n    return {\n        type: SET_INSIGHT_VIEWER_DIALOG,\n        payload: data\n    }\n};\n\nexport const setDocumentStyleDialog = data => ({\n    // data = {\n    // x: px,\n    // y: px,\n    // active: bool,\n    // lockThreshold: px\n    // }\n    type: SET_DOCUMENT_STYLE_DIALOG,\n    payload: data\n});\n\nexport const setDocumentFontName = font => {\n    return {\n        type: SET_DOCUMENT_FONT_NAME,\n        payload: font\n    }\n}\n\nexport const setDocumentFontSize = size => {\n    return {\n        type: SET_DOCUMENT_FONT_SIZE,\n        payload: size\n    }\n}\n\nexport const setNightMode = bool => {\n    return {\n        type: SET_NIGHT_MODE,\n        payload: bool\n    }\n}\n\nexport const setPageLayout = bool => {\n    return {\n        type: SET_PAGE_LAYOUT,\n        payload: bool\n    }\n}\n\nexport const setInsightFilter = filter => {\n    return {\n        type: SET_INSIGHT_FILTER,\n        payload: filter\n    }\n}\n\nexport const setReadingPageInsightDialog = data => {\n    return {\n        type: SET_READING_PAGE_INSIGHT_DIALOG,\n        payload: data\n    }\n}\n\nexport const setReadingPageSearchDialog = data => {\n    return {\n        type: SET_READING_PAGE_SEARCH_DIALOG,\n        payload: data\n    }\n}\n\nexport const setQuotePersistence = bool => {\n    return {\n        type: SET_QUOTE_PERSISTENCE,\n        payload: bool\n    }\n}\n\nexport const setAutoNightMode = bool => {\n    return {\n        type: SET_AUTO_NIGHT_MODE,\n        payload: bool\n    }\n}\n\nexport const setEmailPerNotification = bool => {\n    return {\n        type: SET_EMAIL_PER_NOTIFICATION,\n        payload: bool\n    }\n}\n\nexport const setDailyEmailSummary = bool => {\n    return {\n        type: SET_DAILY_EMAIL_SUMMARY,\n        payload: bool\n    }\n}\n\n// ====== INSIGHTS ======\nexport const createInsight = (docUID, data) => {\n    return (dispatch, getState) => {\n        const state = getState();\n        const currentUserUID = state.profile.currentUser.metadata.uid;\n        const docTitle = state.firestore.data[DOCUMENTS_COLLECTION][docUID].title;\n        let createdNewInsight;\n        console.log(docUID, data);\n        if (isSelectionInsight(data)) {\n            // handle selection insight\n            const selectionInsight = new SelectionInsight(\n                data.visibility.type,\n                data.variant,\n                data.visibility.limitedUsers,\n                data.media.text,\n                data.media.images,\n                data.media.sketches,\n                data.media.links,\n                data.question,\n                // undefined will be replaced by the downloadURL of the selection blob\n                data.variant === InsightVariantTypes.REPLY ? data.quote.box.imageURL : undefined,\n                data.quote.box.canvas.actual,\n                data.quote.box.canvas.visible,\n                data.quote.box.selection.upperLeft,\n                data.quote.box.selection.dimensions,\n                data.quote.box.pageIndex,\n                currentUserUID,\n                docUID,\n                data.parent\n            );\n            const insightCRUDer = new InsightCRUDer(selectionInsight);\n            createdNewInsight = insightCRUDer.createNewInsight(data.quote.box.blob);\n        } else if (isHighlightInsight(data)) {\n            // handle text insight\n            const indexObj = data.quote.text.index;\n            const startIndexObj = {\n                bitIndex: indexObj.bit.start,\n                pageIndex: indexObj.page.start,\n                paragraphIndex: indexObj.paragraph.start,\n            };\n            const endIndexObj = {\n                bitIndex: indexObj.bit.end,\n                pageIndex: indexObj.page.end,\n                paragraphIndex: indexObj.paragraph.end,\n            };\n            const highlightInsight = new HighlightInsight(\n                data.visibility.type,\n                data.variant,\n                data.visibility.limitedUsers,\n                data.media.text,\n                data.media.images,\n                data.media.sketches,\n                data.media.links,\n                data.question,\n                data.quote.text.value,\n                startIndexObj,\n                endIndexObj,\n                currentUserUID,\n                docUID,\n                data.parent\n            );\n            const insightCRUDer = new InsightCRUDer(highlightInsight);\n            createdNewInsight = insightCRUDer.createNewInsight();\n        }\n\n        // TODO: either handle the case for pdf reply insights here or make sure they have\n        // the necessary data in the function that calls this method\n\n        return createdNewInsight\n            .then(completedInsight => {\n                // if (completedInsight.variant === InsightVariantTypes.BASIC) {\n                //     return dispatch(newInsightNotifyConnectionsAndSubscribers(completedInsight))\n                // } else if (completedInsight.variant === InsightVariantTypes.REPLY) {\n                //     return dispatch(newReplyNotifyConnectionsAndSubscribers(completedInsight, docTitle))\n                // }\n            });\n    }\n};\n\nexport const updateDocument = (docUID, updateObj) => {\n    return (_, getState) => {\n        const docMetadata = getState().firestore.data[DOCUMENTS_COLLECTION][docUID];\n        const documentCRUDer = new DocumentCRUDer(docMetadata);\n        return documentCRUDer.updateDocument(updateObj);\n    }\n};\n\nexport const incrementDocumentViews = docUID => {\n    return (_, getState) => {\n        const docMetadata = getState().firestore.data[DOCUMENTS_COLLECTION][docUID];\n        const documentCRUDer = new DocumentCRUDer(docMetadata);\n        return documentCRUDer.incrementViews();\n    }\n};\n\nexport const setSketch = (data) => {\n    return {\n        // data: {url, blob}\n        type: SET_SKETCH,\n        payload: data\n    }\n};\n\nexport const updateInsight = (uid, updateObj) => {\n    return dispatch => {\n        InsightCRUDer.UpdateExistingInsight(uid, updateObj)\n            .then(() => {\n                return dispatch({\n                    type: UPDATE_INSIGHT,\n                    payload: uid\n                })\n            });\n    }\n};\n\nexport const deleteInsight = insight => {\n    return dispatch => {\n        // perform the business logic of deleting an insight\n        let insightCRUDer, paragraphs;\n        if (isSelectionInsight(insight)) {\n            // handle selection insight\n            const selectionInsight = new SelectionInsight(\n                insight.visibility.type,\n                insight.variant,\n                insight.visibility.limitedUsers,\n                insight.media.text,\n                insight.media.images,\n                insight.media.sketches,\n                insight.media.links,\n                insight.question,\n                insight.quote.box.imageURL,\n                insight.quote.box.canvas.actual,\n                insight.quote.box.canvas.visible,\n                insight.quote.box.selection.upperLeft,\n                insight.quote.box.selection.dimensions,\n                insight.quote.box.pageIndex,\n                insight.user,\n                insight.doc,\n                insight.parent,\n                insight.uid\n            );\n            insightCRUDer = new InsightCRUDer(selectionInsight);\n        } else if (isHighlightInsight(insight)) {\n            // handle text insight\n            const indexObj = insight.quote.text.index;\n            const startIndexObj = {\n                bitIndex: indexObj.bit.start,\n                pageIndex: indexObj.page.start,\n                paragraphIndex: indexObj.paragraph.start,\n            };\n            const endIndexObj = {\n                bitIndex: indexObj.bit.end,\n                pageIndex: indexObj.page.end,\n                paragraphIndex: indexObj.paragraph.end,\n            };\n            const highlightInsight = new HighlightInsight(\n                insight.visibility.type,\n                insight.variant,\n                insight.visibility.limitedUsers,\n                insight.media.text,\n                insight.media.images,\n                insight.media.sketches,\n                insight.media.links,\n                insight.question,\n                insight.quote.text.value,\n                startIndexObj,\n                endIndexObj,\n                insight.user,\n                insight.doc,\n                insight.parent,\n                insight.uid\n            );\n            insightCRUDer = new InsightCRUDer(highlightInsight);\n            paragraphs = {\n                start: startIndexObj.paragraphIndex,\n                end: endIndexObj.paragraphIndex,\n            }\n        }\n\n        return insightCRUDer.deleteInsight()\n            .then(() => {\n                // if insight is of variant basic unselect it\n                if (!insight.parent) {\n                    dispatch({\n                        type: DELETE_INSIGHT,\n                        payload: {\n                            insightUID: insight.uid,\n                            paragraphs,\n                        }\n                    });\n                }\n            })\n    }\n};\n\nexport const viewQuoteInContext = insightUID => {\n    return (dispatch, getState) => {\n        const insight = getInsightsCollectionFromStore(getState())[insightUID];\n        dispatch(setInsightViewerDialog({active: false}));\n        const payload = {\n            stagedMarginalia: {\n                highlights: {},\n                selections: {},\n            },\n            seeInContext: {\n                highlights: {},\n                selections: {},\n            },\n        };\n        if (isHighlightInsight(insight)) {\n            payload.stagedMarginalia.highlights = {\n                [insightUID]: {\n                    startBit: insight.quote.text.index.bit.start,\n                    endBit: insight.quote.text.index.bit.end,\n                    isQuestion: insight.isQuestion === QuestionStates.UNRESOLVED_QUESTION,\n                }\n            };\n            payload.seeInContext.highlights = {\n                pageIndex: insight.quote.text.index.page.start,\n                paragraphIndex: insight.quote.text.index.paragraph.start,\n                insightUID,\n            };\n        } else if (isSelectionInsight(insight)) {\n            payload.stagedMarginalia.selections = {\n                [insightUID]: {\n                    uid: insightUID,\n                    isQuestion: insight.isQuestion === QuestionStates.UNRESOLVED_QUESTION,\n                }\n            };\n            payload.seeInContext.selections = {\n                pageIndex: insight.quote.box.pageIndex,\n                insightUID,\n            };\n        }\n\n        return dispatch({\n            type: NAVIGATE_TO_QUOTE_CONTEXT,\n            payload,\n        });\n    };\n};\n\nexport const setCurrentPage = (docUID, pageIndex) => {\n    return (_, getState) => {\n        const currentUser = getState().profile.currentUser.metadata;\n        return firestore\n                .collection(USERS_COLLECTION)\n                .doc(currentUser.uid)\n                .collection(USERS_DOCUMENT_COLLECTION)\n                .doc(docUID)\n                .get()\n                .then(doc => doc.exists\n                    ? doc.ref.update({ currentPage: pageIndex })\n                    : doc.ref.set({ currentPage: pageIndex }));\n    };\n};\n\nexport const setDocumentLastOpened = docUID => {\n    return (_, getState) => {\n        const currentUser = getState().profile.currentUser.metadata;\n        return firestore\n            .collection(USERS_COLLECTION)\n            .doc(currentUser.uid)\n            .collection(USERS_DOCUMENT_COLLECTION)\n            .doc(docUID)\n            .get()\n            .then(doc => {\n                const docData = { lastOpened: new Date().getTime() };\n                return doc.exists ? doc.ref.update(docData) : doc.ref.set(docData);\n            });\n    };\n};\n\nexport const updatedUnloadedReadingPageBucketIndex = bucketIndex => {\n    return {\n        type: UPDATE_UNLOADED_PAGES_BUCKET_INDEX,\n        payload: bucketIndex,\n    }\n};\n\nexport const resetUnloadedReadingPageBucket = () => {\n    return {\n        type: RESET_UNLOADED_READING_PAGE_BUCKET,\n    }\n};\n\nexport const setStagedMarginalia = (marginalia, active) => {\n    const payload = {\n        highlights: {},\n        selections: {},\n    };\n    if (active) {\n        // stage specific marginalia\n        for (const insightUID in marginalia) {\n            if (marginalia.hasOwnProperty(insightUID)) {\n                const insight = marginalia[insightUID];\n                const isQuestion = insight.isQuestion === QuestionStates.UNRESOLVED_QUESTION;\n                if (isSelectionInsight(insight)) {\n                    payload.selections[insightUID] = {\n                        uid: insightUID,\n                        isQuestion,\n                    };\n                } else if (isHighlightInsight(insight)) {\n                    payload.highlights[insightUID] = {\n                        startBit: insight.quote.text.index.bit.start,\n                        endBit: insight.quote.text.index.bit.end,\n                        isQuestion,\n                    }\n                }\n            }\n        }\n\n        return {\n            type: STAGE_MARGINALIA,\n            payload,\n        }\n    } else {\n        // unstage specific marginalia\n        const marginaliaUIDs = Object.keys(marginalia);\n        payload.highlights = marginaliaUIDs;\n        payload.selections = marginaliaUIDs;\n        return {\n            type: UNSTAGE_MARGINALIA,\n            payload,\n        }\n    }\n};\n\nexport const unstageAllMarginalia = () => {\n    return {\n        type: UNSTAGE_ALL_HIGHLIGHT_MARGINALIA\n    }\n};\n\nexport const setBucketIndex2Insights = newBucketIndex2Insights => {\n    return {\n        type: SET_BUCKET_INDEX_2_INSIGHTS,\n        payload: newBucketIndex2Insights,\n    }\n};\n\nexport const resetInsightStore = () => {\n    return {\n        type: CLEAR_BUCKET_INDEX_2_INSIGHTS,\n    }\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/actions/ReadingPageActions.js	(date 1543432850000)
+++ app/actions/ReadingPageActions.js	(date 1543445192834)
@@ -480,6 +480,7 @@
 };
 
 export const setStagedMarginalia = (marginalia, active) => {
+    console.log('setStagedMarginalia', marginalia, active);
     const payload = {
         highlights: {},
         selections: {},
Index: app/components/ReadingPage/DocumentAssets/AbstractParagraph.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Libs\nimport React                from 'react';\nimport PropTypes            from 'prop-types';\nimport styled               from 'styled-components';\nimport uuid                 from 'uuid';\nimport {\n    isEqual,\n    mapValues,\n    difference,\n    isEmpty\n}            from 'lodash';\nimport { connect }          from 'react-redux';\n\n// Actions\nimport {\n    setInsightViewerDialog,\n    setSelectedInsight,\n    setStagedMarginalia,\n} from \"../../../actions/ReadingPageActions\";\n\nimport {\n    insightIsQuote\n} from \"../../../actions/Utils\";\n\n// Components\nimport Word                 from './Word';\nimport Media                from './Media';\nimport MarginaliaCard       from '../../MarginaliaCard';\nimport MarginaliaContractor from '../../MarginaliaContractor';\n\n// Constants\nimport DocumentElementTypes from '../../../constants/documentElementTypes.js';\n\nconst mapStateToProps = state => {\n    return {\n        stagedMarginalia: state.insights.stagedMarginalia.highlights,\n        settings: state.profile.settings\n    }\n};\n\nconst mapDispatchToProps = dispatch => {\n    return {\n        setInsightViewerDialog: data => dispatch(setInsightViewerDialog(data)),\n        setSelectedInsight: (insightUID, paragraphIndex) => dispatch(setSelectedInsight(insightUID, paragraphIndex)),\n        setStagedMarginalia: (marginalia, active) => dispatch(setStagedMarginalia(marginalia, active)),\n    };\n};\n\n/**\n * The Paragraph component is a component used to\n */\nclass AbstractParagraph extends React.Component {\n    // ============= PropTypes ==============\n\n    static propTypes = {\n        data: PropTypes.object.isRequired,\n        pageIndex: PropTypes.number.isRequired,\n        activeDoc: PropTypes.object.isRequired,\n        marginalia: PropTypes.object.isRequired,\n        setInsightViewerDialog: PropTypes.func.isRequired,\n        setSelectedInsight: PropTypes.func.isRequired,\n        heightBuffer: PropTypes.number.isRequired,\n        prefix: PropTypes.string.isRequired,\n        settings: PropTypes.object.isRequired\n    };\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            dimensions: {\n                width: null,\n                height: null\n            },\n            marginalia: {},\n            marginaliaContractor: {\n                users: [],\n                insights: {},\n                quotes: {}\n            },\n        };\n        this.computeWordHighlightState = this.computeWordHighlightState.bind(this);\n    }\n\n    componentWillMount() {\n        //console.log(\"-----Paragraph\");\n    }\n\n    render() {\n        const elements = this.props.data.elements.reduce((elements, element) => {return elements.concat(element.elements)},[]);\n        return (\n            <React.Fragment>\n                {elements.map((element) => {\n                    const bitIndex = element.index.bitIndex;\n                    switch(element[\"class\"]) {\n                        case DocumentElementTypes.classes.word.NAME: {\n                            return (\n                                <Word\n                                    key={bitIndex}\n                                    data={element}\n                                    pageIndex={this.props.pageIndex}\n                                    highlighted={this.computeWordHighlightState(bitIndex)}\n                                    fontWeight={400} />\n                            );\n                        }\n                        case DocumentElementTypes.classes.media.NAME: {\n                            return (\n                                <Media\n                                    key={uuid.v4()}\n                                    data={element}\n                                    pageIndex={this.props.pageIndex} />\n                            );\n                        }\n                        default: {\n                            console.error(\"ERROR - Unclassified Paragraph Element: \", element);\n                        }\n                    }\n                })}\n                <MarginaliaContainer>\n                    {Object.keys(this.props.marginalia)\n                        .filter(uid => {\n                            return this.state.marginalia[uid] && this.state.marginalia[uid].visible\n                        })\n                        .sort((a,b) => {\n                            if (insightIsQuote(this.props.marginalia[a]) && !insightIsQuote(this.props.marginalia[b])) {\n                                return -1;\n                            } else if (!insightIsQuote(this.props.marginalia[a]) && insightIsQuote(this.props.marginalia[b])) {\n                                return 1;\n                            } else {\n                                return this.props.marginalia[b].timestamp - this.props.marginalia[a].timestamp;\n                            }\n                        })\n                        .map(uid => {\n                            const note = this.props.marginalia[uid];\n                            return (\n                                <MarginaliaCard\n                                    key={uid}\n                                    data={note}\n                                    paragraphIndex={this.props.data.index.paragraphIndex}\n                                    docUID={this.props.activeDoc.uid}\n                                    orientation={\"left\"}\n                                    handleOnLoad={() => {this.handleNoteOnLoad(uid)}}\n                                    handleHover={active => this.props.setStagedMarginalia({[uid]: note}, active)} />\n                            );\n                        })}\n                    {\n                        (Object.keys(this.state.marginaliaContractor.insights).length > 0 || Object.keys(this.state.marginaliaContractor.quotes).length > 0) &&\n                        <MarginaliaContractor\n                            data={{\n                                ...this.state.marginaliaContractor.insights,\n                                ...this.state.marginaliaContractor.quotes\n                            }}\n                            orientation={\"left\"}\n                            allParagraphMarginalia={(Object.keys(this.state.marginaliaContractor.insights).length + Object.keys(this.state.marginaliaContractor.quotes).length) === Object.keys(this.props.marginalia).length}\n                            userUIDs={this.state.marginaliaContractor.users}\n                            numInsights={Object.keys(this.state.marginaliaContractor.insights).length}\n                            numQuotes={Object.keys(this.state.marginaliaContractor.quotes).length}\n                            handleHover={active => this.props.setStagedMarginalia({\n                                ...this.state.marginaliaContractor.insights,\n                                ...this.state.marginaliaContractor.quotes\n                            }, active)}\n                            handleClick={() => {this.handleContractorClick({\n                                ...this.state.marginaliaContractor.insights,\n                                ...this.state.marginaliaContractor.quotes\n                            })}} />\n                    }\n                </MarginaliaContainer>\n            </React.Fragment>\n        );\n    }\n\n    componentWillReceiveProps(nextProps) {\n        // determine if any new marginalia were created that need to be displayed\n        const newMarginaliaToDisplay = difference(Object.keys(nextProps.marginalia), Object.keys(this.state.marginalia))\n            .reduce((acc, uid) => {\n                acc[uid] = {visible: true};\n                return acc;\n            }, {});\n        if (!isEmpty(newMarginaliaToDisplay)) {\n            this.setState({\n                marginalia: {\n                    ...this.state.marginalia,\n                    ...newMarginaliaToDisplay,\n                }\n            });\n        }\n\n        if (this.props.settings.fontSize != nextProps.settings.fontSize && !isEmpty(this.state.marginalia)) {\n            this.setState({\n                marginalia: {},\n                marginaliaContractor: {\n                    users: [],\n                    insights: {},\n                    quotes: {}\n                }\n            });\n        }\n    }\n\n    componentDidMount() {\n        //console.log(\"+++++Paragraph\");\n\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        const shouldUpdate = document.getElementById(`${this.props.prefix}-${this.props.data.index.paragraphIndex}`)\n        && (\n            !(\n                Object.keys(this.props.stagedMarginalia).length !== Object.keys(nextProps.stagedMarginalia).length\n                && isEqual(this.state.dimensions, nextState.dimensions)\n                && isEqual(this.state.marginalia, nextState.marginalia)\n                && this.props.settings.fontSize === nextProps.settings.fontSize\n            )\n                ||  Object.keys(this.props.marginalia).length === Object.keys(nextProps.marginalia).length\n            );\n        return shouldUpdate\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const paragraphNode = document.getElementById(`${this.props.prefix}-${this.props.data.index.paragraphIndex}`);\n        const paragraphHeight = paragraphNode.clientHeight;\n        let cumulativeHeight = 0;\n        const stateMarginalia = this.state.marginalia;\n        const propsMarginalia = this.props.marginalia;\n        const initialReduceState = {\n            newMarginalia: {},\n            newMarginaliaContractor: {\n                users: [],\n                insights: {},\n                quotes: {}\n            }\n        };\n\n        // compute the newest version of state.marginalia and state.marginaliaContractor\n        const {newMarginalia, newMarginaliaContractor} = Object.keys(stateMarginalia)\n            .reduce((acc, uid) => {\n                // if state has an insight that is not in props (it was deleted),\n                // then it must be removed from state\n                const actualInsight = propsMarginalia[uid];\n                if (!actualInsight) { return acc }\n\n                const insightStateData = stateMarginalia[uid];\n                const marginaliaHeight = insightStateData.height;\n                if (cumulativeHeight + marginaliaHeight + this.props.heightBuffer > paragraphHeight) {\n                    acc.newMarginalia[uid] = { ...insightStateData, visible: false };\n                    acc.newMarginaliaContractor.users.push(actualInsight.user);\n                    if (insightIsQuote(actualInsight)) {\n                        acc.newMarginaliaContractor.quotes[uid] = actualInsight;\n                    } else {\n                        acc.newMarginaliaContractor.insights[uid] = actualInsight;\n                    }\n                    return acc;\n                } else {\n                    cumulativeHeight += marginaliaHeight;\n                    acc.newMarginalia[uid] = insightStateData;\n                }\n                return acc;\n            }, initialReduceState);\n\n        if (!isEqual(newMarginalia, stateMarginalia)) {\n            this.setState({\n                dimensions: {\n                    width: paragraphNode.clientWidth,\n                    height: paragraphHeight,\n                },\n                marginalia: newMarginalia,\n                marginaliaContractor: newMarginaliaContractor,\n            });\n        }\n    }\n\n    // ========== Methods ===========\n\n    computeWordHighlightState = bitIndex => {\n        let highlighted = {\n            active: false,\n            isQuestion: false\n        };\n\n        const stagedMarginalia = this.props.stagedMarginalia;\n        for (const stagedMarginaliaUID in stagedMarginalia) {\n            if (stagedMarginalia.hasOwnProperty(stagedMarginaliaUID)) {\n                const {startBit, endBit, isQuestion} = stagedMarginalia[stagedMarginaliaUID];\n                highlighted.isQuestion = isQuestion;\n                if (startBit <= bitIndex && bitIndex <= endBit) {\n                    highlighted.active = true\n                }\n            }\n        }\n\n        return highlighted;\n    };\n\n    handleNoteOnLoad = (uid) => {\n        let node = document.getElementById(`note=${uid}`);\n        this.state.marginalia = {\n            ...this.state.marginalia,\n            [uid]: {\n                visible: this.state.marginalia[uid].visible,\n                height: node.clientHeight\n            }\n        }\n    }\n\n    handleContractorClick = (marginalia) => {\n        this.props.setInsightViewerDialog({active: true});\n        const insightUID = marginalia[Object.keys(marginalia)[0]].uid;\n        this.props.setSelectedInsight(insightUID, this.props.data.index.paragraphIndex);\n    }\n}\n\n// ============= Styled Components ==============\n\nconst MarginaliaContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: flex-start;\n    position: absolute;\n    top: 0;\n    right: -30px;\n    max-width: 500px;\n    font-size: 1em;\n    transform: translateX(100%);\n\n    @media (max-width: 100ch) {\n        right: 0px;\n        transform: translateX(0%);\n        width: auto;\n    }\n`;\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(AbstractParagraph);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/components/ReadingPage/DocumentAssets/AbstractParagraph.js	(date 1543432850000)
+++ app/components/ReadingPage/DocumentAssets/AbstractParagraph.js	(date 1543450470412)
@@ -31,7 +31,7 @@
 // Constants
 import DocumentElementTypes from '../../../constants/documentElementTypes.js';
 
-const mapStateToProps = state => {
+const mapStateToProps = (state, props) => {
     return {
         stagedMarginalia: state.insights.stagedMarginalia.highlights,
         settings: state.profile.settings
@@ -86,6 +86,7 @@
     }
 
     render() {
+        console.log('AbstractParagraph render', this.props.stagedMarginalia);
         const elements = this.props.data.elements.reduce((elements, element) => {return elements.concat(element.elements)},[]);
         return (
             <React.Fragment>
@@ -115,7 +116,7 @@
                         }
                     }
                 })}
-                <MarginaliaContainer>
+                <MarginaliaContainer >
                     {Object.keys(this.props.marginalia)
                         .filter(uid => {
                             return this.state.marginalia[uid] && this.state.marginalia[uid].visible
@@ -134,12 +135,15 @@
                             return (
                                 <MarginaliaCard
                                     key={uid}
-                                    data={note}
+                                    insightUID={uid}
                                     paragraphIndex={this.props.data.index.paragraphIndex}
                                     docUID={this.props.activeDoc.uid}
                                     orientation={"left"}
                                     handleOnLoad={() => {this.handleNoteOnLoad(uid)}}
-                                    handleHover={active => this.props.setStagedMarginalia({[uid]: note}, active)} />
+                                    handleHover={active => {
+                                        console.log('handleHover');
+                                        this.props.setStagedMarginalia({[uid]: note}, active)
+                                    }} />
                             );
                         })}
                     {
@@ -202,17 +206,16 @@
     }
 
     shouldComponentUpdate(nextProps, nextState) {
-        const shouldUpdate = document.getElementById(`${this.props.prefix}-${this.props.data.index.paragraphIndex}`)
-        && (
-            !(
-                Object.keys(this.props.stagedMarginalia).length !== Object.keys(nextProps.stagedMarginalia).length
-                && isEqual(this.state.dimensions, nextState.dimensions)
-                && isEqual(this.state.marginalia, nextState.marginalia)
-                && this.props.settings.fontSize === nextProps.settings.fontSize
+        return (
+                !(
+                    Object.keys(this.props.stagedMarginalia).length === Object.keys(nextProps.stagedMarginalia).length
+                    && isEqual(this.state.dimensions, nextState.dimensions)
+                    && isEqual(this.state.marginalia, nextState.marginalia)
+                    && this.props.settings.fontSize === nextProps.settings.fontSize
+                )
+                ||  Object.keys(this.props.marginalia).length !== Object.keys(nextProps.marginalia).length
             )
-                ||  Object.keys(this.props.marginalia).length === Object.keys(nextProps.marginalia).length
-            );
-        return shouldUpdate
+            && !!document.getElementById(`${this.props.prefix}-${this.props.data.index.paragraphIndex}`);
     }
 
     componentDidUpdate(prevProps, prevState) {
